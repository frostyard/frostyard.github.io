{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Frostyard","text":"<p>Frostyard builds secure, reproducible OCI-based Linux desktop and server images, plus tooling for post-install customization and lifecycle management.</p> <p>Explore each section for full documentation, usage, and development instructions.</p>"},{"location":"#atomic-linux-basics","title":"Atomic Linux Basics","text":"<ul> <li>What is Atomic</li> </ul>"},{"location":"#images","title":"Images","text":"<ul> <li>Snow</li> </ul>"},{"location":"#tools","title":"Tools","text":"<ul> <li>Chairlift</li> </ul>"},{"location":"atomic/","title":"Atomic Linux Images","text":"<p>What does this mean?</p>"},{"location":"images/snow/reference/","title":"Snow Reference","text":"<p>I'm snow content.</p>"},{"location":"tools/chairlift/reference/","title":"reference","text":"<p>I'm content.</p>"},{"location":"tools/nbc/AB-UPDATES/","title":"A/B Update System","text":""},{"location":"tools/nbc/AB-UPDATES/#overview","title":"Overview","text":"<p>The <code>nbc update</code> command implements an A/B (dual root) update system that enables safe, atomic system updates with automatic rollback capability.</p>"},{"location":"tools/nbc/AB-UPDATES/#how-it-works","title":"How It Works","text":""},{"location":"tools/nbc/AB-UPDATES/#partition-layout","title":"Partition Layout","text":"<pre><code>/dev/sdX1 - EFI (2GB)          - Boot files\n/dev/sdX2 - Boot (1GB)         - Kernels and initramfs\n/dev/sdX3 - Root1 (12GB)       - Primary root filesystem\n/dev/sdX4 - Root2 (12GB)       - Secondary root filesystem\n/dev/sdX5 - Var (remaining)    - Shared /var data\n</code></pre>"},{"location":"tools/nbc/AB-UPDATES/#update-process","title":"Update Process","text":"<ol> <li> <p>Detect Active Partition</p> </li> <li> <p>Reads <code>/proc/cmdline</code> to determine which root partition is currently booted</p> </li> <li> <p>Identifies the inactive partition as the update target</p> </li> <li> <p>Check If Update Needed</p> </li> <li> <p>Compares installed image digest with remote image digest</p> </li> <li>Skips update if digests match (system is up-to-date)</li> <li> <p>Use <code>--force</code> to reinstall even if up-to-date</p> </li> <li> <p>Pull New Image</p> </li> <li> <p>Downloads the latest container image using go-containerregistry</p> </li> <li> <p>Alternatively, uses a pre-staged image from local cache (see <code>nbc download --for-update</code>)</p> </li> <li> <p>Extract to Inactive Partition</p> </li> <li> <p>Mounts the inactive root partition</p> </li> <li>Clears existing content</li> <li> <p>Extracts new container filesystem</p> </li> <li> <p>Update Bootloader</p> </li> <li> <p>Updates GRUB configuration to boot from the new partition</p> </li> <li>Sets new partition as default boot option</li> <li> <p>Keeps old partition as fallback in boot menu</p> </li> <li> <p>Reboot to Activate</p> </li> <li>Next boot uses the updated partition</li> <li>Previous partition remains available for rollback</li> </ol>"},{"location":"tools/nbc/AB-UPDATES/#usage","title":"Usage","text":""},{"location":"tools/nbc/AB-UPDATES/#check-for-updates","title":"Check for Updates","text":"<pre><code># Check if an update is available without installing\nsudo nbc update --check\n</code></pre>"},{"location":"tools/nbc/AB-UPDATES/#basic-update","title":"Basic Update","text":"<pre><code>sudo nbc update \\\n  --image quay.io/example/myimage:latest\n</code></pre> <p>The device is automatically detected from the running system. Override with <code>--device</code> if needed.</p>"},{"location":"tools/nbc/AB-UPDATES/#update-with-custom-kernel-arguments","title":"Update with Custom Kernel Arguments","text":"<pre><code>sudo nbc update \\\n  --image localhost/custom-image \\\n  --karg console=ttyS0 \\\n  --karg quiet\n</code></pre>"},{"location":"tools/nbc/AB-UPDATES/#skip-image-pull-use-cached","title":"Skip Image Pull (Use Cached)","text":"<pre><code>sudo nbc update \\\n  --image localhost/myimage \\\n  --skip-pull\n</code></pre>"},{"location":"tools/nbc/AB-UPDATES/#staged-updates-download-now-apply-later","title":"Staged Updates (Download Now, Apply Later)","text":"<p>Download an update image without applying it:</p> <pre><code># Download update using system's configured image\nsudo nbc download --for-update\n\n# Or specify a different image\nsudo nbc download --for-update --image quay.io/example/myimage:v2.0\n</code></pre> <p>Apply the staged update later:</p> <pre><code># Apply the previously downloaded update\nsudo nbc update --local-image\n</code></pre> <p>Check staged update status:</p> <pre><code>nbc status --json\n</code></pre> <p>The staged update cache is automatically cleared after successful application.</p>"},{"location":"tools/nbc/AB-UPDATES/#dry-run-test","title":"Dry Run Test","text":"<pre><code>nbc update \\\n  --image test/image \\\n  --dry-run\n</code></pre>"},{"location":"tools/nbc/AB-UPDATES/#boot-menu-options","title":"Boot Menu Options","text":"<p>After an update, the GRUB boot menu provides two options:</p> <pre><code>1. Linux (Updated)    - New system (default)\n2. Linux (Previous)   - Previous system (rollback)\n</code></pre>"},{"location":"tools/nbc/AB-UPDATES/#rollback-procedure","title":"Rollback Procedure","text":"<p>If the new system has issues, you can rollback by:</p> <ol> <li>At Boot Time: Select \"Linux (Previous)\" from GRUB menu</li> <li>After Booting: Run another update to switch back</li> </ol>"},{"location":"tools/nbc/AB-UPDATES/#file-organization","title":"File Organization","text":""},{"location":"tools/nbc/AB-UPDATES/#implementation-files","title":"Implementation Files","text":"<ul> <li> <p>pkg/update.go - Update logic and A/B switching</p> </li> <li> <p><code>GetActiveRootPartition()</code> - Detects current root</p> </li> <li><code>GetInactiveRootPartition()</code> - Finds update target</li> <li><code>SystemUpdater</code> - Main update orchestrator</li> <li> <p><code>UpdateBootloader()</code> - GRUB configuration updates</p> </li> <li> <p>cmd/update.go - CLI command interface</p> </li> </ul>"},{"location":"tools/nbc/AB-UPDATES/#key-functions","title":"Key Functions","text":""},{"location":"tools/nbc/AB-UPDATES/#active-partition-detection","title":"Active Partition Detection","text":"<pre><code>func GetActiveRootPartition() (string, error)\n</code></pre> <p>Reads <code>/proc/cmdline</code> to determine which root partition the system booted from.</p>"},{"location":"tools/nbc/AB-UPDATES/#inactive-partition-selection","title":"Inactive Partition Selection","text":"<pre><code>func GetInactiveRootPartition(scheme *PartitionScheme) (string, bool, error)\n</code></pre> <p>Returns the partition that should receive the update.</p>"},{"location":"tools/nbc/AB-UPDATES/#update-execution","title":"Update Execution","text":"<pre><code>func (u *SystemUpdater) Update() error\n</code></pre> <p>Performs the complete update:</p> <ol> <li>Mount target partition</li> <li>Clear old content</li> <li>Extract new filesystem</li> <li>Update bootloader configuration</li> </ol>"},{"location":"tools/nbc/AB-UPDATES/#advantages","title":"Advantages","text":"<p>\u2705 Atomic Updates: Either fully succeeds or fully fails - no partial states \u2705 Zero Downtime: System remains operational during update \u2705 Instant Rollback: Switch back to previous version at boot time \u2705 Safe Testing: New system can be tested before commitment \u2705 Shared Data: /var partition is shared, preserving application data</p>"},{"location":"tools/nbc/AB-UPDATES/#safety-features","title":"Safety Features","text":"<ul> <li>Confirmation Prompt: Requires explicit \"yes\" to proceed</li> <li>Dry Run Mode: Test without making changes</li> <li>Separate Partitions: Update failure doesn't affect running system</li> <li>Boot Menu: Always provides fallback option</li> <li>Data Preservation: /var remains untouched during updates</li> </ul>"},{"location":"tools/nbc/AB-UPDATES/#update-workflow-example","title":"Update Workflow Example","text":"<pre><code># Initial installation (creates both root partitions)\nsudo nbc install \\\n  --image myimage:v1.0 \\\n  --device /dev/sda\n\n# Reboot into root1 (partition 3)\n\n# First update (writes to root2 - partition 4)\nsudo nbc update \\\n  --image myimage:v1.1 \\\n  --device /dev/sda\n\n# Reboot into root2 (partition 4)\n# root1 still has v1.0 for rollback\n\n# Second update (writes back to root1 - partition 3)\nsudo nbc update \\\n  --image myimage:v1.2 \\\n  --device /dev/sda\n\n# Reboot into root1 (partition 3)\n# root2 still has v1.1 for rollback\n</code></pre>"},{"location":"tools/nbc/AB-UPDATES/#technical-details","title":"Technical Details","text":""},{"location":"tools/nbc/AB-UPDATES/#partition-state-detection","title":"Partition State Detection","text":"<p>The system determines the active partition by parsing kernel command line:</p> <pre><code>$ cat /proc/cmdline\nBOOT_IMAGE=/vmlinuz-6.5.0 root=UUID=xxx-xxx-xxx ro console=tty0\n</code></pre> <p>The UUID is matched against partition UUIDs to identify which root is active.</p>"},{"location":"tools/nbc/AB-UPDATES/#grub-configuration","title":"GRUB Configuration","text":"<p>After update, GRUB config provides both options:</p> <pre><code>set timeout=5\nset default=0\n\nmenuentry 'Linux (Updated)' {\n    linux /vmlinuz-6.5.0 root=UUID=new-uuid ro console=tty0\n    initrd /initramfs-6.5.0.img\n}\n\nmenuentry 'Linux (Previous)' {\n    linux /vmlinuz-6.5.0 root=UUID=old-uuid ro console=tty0\n    initrd /initramfs-6.5.0.img\n}\n</code></pre>"},{"location":"tools/nbc/AB-UPDATES/#shared-var-partition","title":"Shared /var Partition","text":"<p>Both root filesystems mount the same /var partition, ensuring:</p> <ul> <li>Application data persists across updates</li> <li>Logs are maintained</li> <li>Databases remain accessible</li> <li>Configuration in /var is preserved</li> </ul>"},{"location":"tools/nbc/AB-UPDATES/#encryption-support","title":"Encryption Support","text":"<p>A/B updates fully support LUKS-encrypted systems. The encryption configuration is stored in <code>/var/lib/nbc/state/config.json</code> during installation and automatically loaded during updates.</p> <p>For encrypted systems, the update process:</p> <ol> <li>Reads encryption config from the system config file</li> <li>Generates correct LUKS kernel arguments for each root partition:</li> <li><code>rd.luks.uuid</code> - LUKS container UUID</li> <li><code>rd.luks.name</code> - Mapper device name (root1, root2, or var)</li> <li><code>rd.luks.options</code> - TPM2 unlock options (if enabled)</li> <li>Creates separate boot entries with the appropriate LUKS UUIDs for:</li> <li>Target partition (the one being updated)</li> <li>Active partition (for rollback)</li> </ol> <p>The system config stores LUKS UUIDs for all partitions:</p> <pre><code>{\n  \"encryption\": {\n    \"enabled\": true,\n    \"tpm2\": true,\n    \"root1_luks_uuid\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n    \"root2_luks_uuid\": \"yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\",\n    \"var_luks_uuid\": \"zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz\"\n  }\n}\n</code></pre> <p>This ensures that after an update, both boot entries (new and previous) have the correct LUKS kernel arguments for their respective root partitions.</p>"},{"location":"tools/nbc/AB-UPDATES/#comparison-to-other-systems","title":"Comparison to Other Systems","text":""},{"location":"tools/nbc/AB-UPDATES/#vs-traditional-package-updates","title":"vs Traditional Package Updates","text":"<ul> <li>\u2705 Atomic (all-or-nothing)</li> <li>\u2705 Instant rollback</li> <li>\u2705 No package conflicts</li> </ul>"},{"location":"tools/nbc/AB-UPDATES/#vs-ostreerpm-ostree","title":"vs OSTree/rpm-ostree","text":"<ul> <li>\u2705 Simpler implementation</li> <li>\u2705 Standard ext4 filesystems</li> <li>\u26a0\ufe0f Larger disk space requirement</li> </ul>"},{"location":"tools/nbc/AB-UPDATES/#vs-dockerkubernetes-updates","title":"vs Docker/Kubernetes Updates","text":"<ul> <li>\u2705 Full system updates (not just containers)</li> <li>\u2705 Includes kernel and bootloader</li> <li>\u2705 Bare metal support</li> </ul>"},{"location":"tools/nbc/AB-UPDATES/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements:</p> <ul> <li>[ ] Automatic health checks before switching</li> <li>[ ] Scheduled updates</li> <li>[ ] Multi-version retention (keep more than 2 versions)</li> <li>[ ] Delta updates (only transfer changes)</li> <li>[ ] Automatic rollback on boot failure</li> <li>[ ] Status command to show active partition</li> <li>[ ] Update history tracking</li> </ul>"},{"location":"tools/nbc/DRY-RUN/","title":"Dry-Run Mode","text":"<p>The <code>--dry-run</code> (or <code>-n</code>) flag allows you to preview what nbc would do without making any actual changes to your system. This is useful for:</p> <ul> <li>Verifying command syntax and options</li> <li>Understanding the installation/update workflow</li> <li>Testing automation scripts safely</li> <li>Debugging issues without risking data</li> </ul>"},{"location":"tools/nbc/DRY-RUN/#usage","title":"Usage","text":"<pre><code># Install command\nnbc install --image quay.io/example/image:latest --device /dev/sda --dry-run\n\n# Short form\nnbc -n install --image quay.io/example/image:latest --device /dev/sda\n\n# Update command\nnbc update --image quay.io/example/image:latest --dry-run\n\n# Can be combined with other flags\nnbc install \\\n  --image quay.io/example/image:latest \\\n  --device /dev/sda \\\n  --encrypt \\\n  --passphrase \"test\" \\\n  --tpm2 \\\n  --dry-run\n</code></pre>"},{"location":"tools/nbc/DRY-RUN/#what-gets-skipped-in-dry-run-mode","title":"What Gets Skipped in Dry-Run Mode","text":"<p>When <code>--dry-run</code> is enabled, the following operations are not performed:</p>"},{"location":"tools/nbc/DRY-RUN/#disk-operations","title":"Disk Operations","text":"<ul> <li>\u2717 Disk wiping (<code>sgdisk --zap-all</code>)</li> <li>\u2717 Partition creation (<code>sgdisk</code>)</li> <li>\u2717 Filesystem formatting (<code>mkfs.ext4</code>, <code>mkfs.vfat</code>, <code>mkfs.btrfs</code>)</li> <li>\u2717 Partition mounting/unmounting</li> </ul>"},{"location":"tools/nbc/DRY-RUN/#luks-encryption","title":"LUKS Encryption","text":"<ul> <li>\u2717 LUKS container creation (<code>cryptsetup luksFormat</code>)</li> <li>\u2717 LUKS container opening (<code>cryptsetup luksOpen</code>)</li> <li>\u2717 TPM2 key enrollment (<code>systemd-cryptenroll</code>)</li> </ul>"},{"location":"tools/nbc/DRY-RUN/#container-operations","title":"Container Operations","text":"<ul> <li>\u2717 Container filesystem extraction</li> <li>\u2717 File and directory creation on target</li> </ul>"},{"location":"tools/nbc/DRY-RUN/#bootloader","title":"Bootloader","text":"<ul> <li>\u2717 GRUB2 installation (<code>grub-install</code>)</li> <li>\u2717 systemd-boot installation (<code>bootctl</code>)</li> <li>\u2717 Kernel and initramfs copying</li> <li>\u2717 Boot configuration file generation</li> <li>\u2717 EFI boot entry registration (<code>efibootmgr</code>)</li> </ul>"},{"location":"tools/nbc/DRY-RUN/#system-configuration","title":"System Configuration","text":"<ul> <li>\u2717 <code>/etc/fstab</code> generation</li> <li>\u2717 <code>/etc/crypttab</code> generation</li> <li>\u2717 System directory setup</li> <li>\u2717 <code>/etc</code> persistence configuration</li> </ul>"},{"location":"tools/nbc/DRY-RUN/#what-still-happens-in-dry-run-mode","title":"What Still Happens in Dry-Run Mode","text":"<p>Some read-only operations are still performed:</p> <ul> <li>\u2713 Image reference validation (checks if image exists)</li> <li>\u2713 Device path resolution</li> <li>\u2713 Prerequisite tool checks</li> <li>\u2713 Command-line argument validation</li> <li>\u2713 Progress messages showing what would happen</li> </ul>"},{"location":"tools/nbc/DRY-RUN/#output-example","title":"Output Example","text":"<pre><code>$ nbc install --image localhost/myimage:latest --device /dev/sda --dry-run\n\nChecking prerequisites...\nValidating disk /dev/sda...\n[DRY RUN] Would pull image: localhost/myimage:latest\n[DRY RUN] Would install localhost/myimage:latest to /dev/sda\n</code></pre>"},{"location":"tools/nbc/DRY-RUN/#implementation-details","title":"Implementation Details","text":"<p>The dry-run protection uses an early-return gate pattern. High-level functions check the <code>dryRun</code> flag at entry and return immediately before performing any modifications:</p> <pre><code>func (b *BootcInstaller) Install() error {\n    if b.DryRun {\n        p.MessagePlain(\"[DRY RUN] Would install %s to %s\", b.ImageRef, b.Device)\n        return nil\n    }\n    // ... actual installation code ...\n}\n</code></pre> <p>This pattern ensures that all downstream operations (partition creation, formatting, bootloader installation, etc.) are never reached when dry-run mode is enabled.</p>"},{"location":"tools/nbc/DRY-RUN/#protected-entry-points","title":"Protected Entry Points","text":"Function Protection <code>BootcInstaller.Install()</code> Returns before disk operations <code>BootcInstaller.PullImage()</code> Returns before network operations <code>BootcInstaller.Verify()</code> Returns before verification <code>SystemUpdater.Update()</code> Returns before update operations <code>SystemUpdater.PullImage()</code> Returns before network operations <code>CreatePartitions()</code> Returns mock partition scheme <code>FormatPartitions()</code> Skips mkfs commands <code>MountPartitions()</code> Skips mount commands <code>SetupLUKS()</code> Skips LUKS creation <code>WipeDisk()</code> Skips disk wiping"},{"location":"tools/nbc/DRY-RUN/#configuration-file","title":"Configuration File","text":"<p>You can set dry-run mode as default in your configuration file:</p> <pre><code># ~/.nbc.yaml\ndry-run: true # Always run in dry-run mode unless explicitly disabled\n</code></pre> <p>To override when dry-run is the default:</p> <pre><code># Currently no --no-dry-run flag, so remove from config to run for real\n</code></pre>"},{"location":"tools/nbc/DRY-RUN/#testing-with-dry-run","title":"Testing with Dry-Run","text":"<p>Dry-run mode is also tested in the unit test suite:</p> <pre><code>make test-unit\n# Includes TestBootcInstaller_DryRun\n</code></pre>"},{"location":"tools/nbc/ENCRYPTION/","title":"Full Disk Encryption (FDE) with LUKS2 and TPM2","text":"<p>nbc supports full disk encryption using LUKS2 with optional TPM2 automatic unlock.</p>"},{"location":"tools/nbc/ENCRYPTION/#quick-start","title":"Quick Start","text":"<pre><code># Install with encryption (passphrase only)\nnbc install --encrypt --passphrase \"your-secure-passphrase\" ghcr.io/myorg/myimage:latest /dev/sda\n\n# Install with encryption + TPM2 automatic unlock\nnbc install --encrypt --passphrase \"your-secure-passphrase\" --tpm2 ghcr.io/myorg/myimage:latest /dev/sda\n</code></pre>"},{"location":"tools/nbc/ENCRYPTION/#how-it-works","title":"How It Works","text":""},{"location":"tools/nbc/ENCRYPTION/#encrypted-partitions","title":"Encrypted Partitions","text":"<p>When <code>--encrypt</code> is specified, the following partitions are encrypted with LUKS2:</p> Partition Mapper Name Description Root1 <code>/dev/mapper/root1</code> Active root filesystem Root2 <code>/dev/mapper/root2</code> Inactive root for A/B updates Var <code>/dev/mapper/var</code> Persistent <code>/var</code> data <p>The ESP (EFI System Partition) and Boot partitions are not encrypted to allow the bootloader to load the kernel and initramfs.</p>"},{"location":"tools/nbc/ENCRYPTION/#encryption-flow","title":"Encryption Flow","text":"<ol> <li>Partition Creation: Standard GPT partitions are created</li> <li>LUKS Setup: Each partition (root1, root2, var) is formatted with LUKS2</li> <li>LUKS Open: Encrypted containers are opened to <code>/dev/mapper/&lt;name&gt;</code></li> <li>Filesystem Creation: ext4 (or btrfs) filesystem is created on the mapper device</li> <li>Container Extraction: OS is extracted to the mounted filesystems</li> <li>Crypttab Generation: <code>/etc/crypttab</code> is generated for boot-time unlock</li> <li>Bootloader Config: Kernel arguments are configured for LUKS unlock</li> <li>TPM2 Enrollment (optional): TPM2 key is enrolled for automatic unlock</li> </ol>"},{"location":"tools/nbc/ENCRYPTION/#kernel-arguments","title":"Kernel Arguments","text":"<p>With encryption enabled, the bootloader is configured with:</p> <pre><code>root=/dev/mapper/root1 rw rd.luks.uuid=&lt;root1-luks-uuid&gt; rd.luks.name=&lt;uuid&gt;=root1 systemd.mount-extra=/dev/mapper/var:/var:ext4:defaults\n</code></pre> <p>With TPM2 enabled, <code>rd.luks.options=tpm2-device=auto</code> is added to enable automatic unlock.</p>"},{"location":"tools/nbc/ENCRYPTION/#tpm2-automatic-unlock","title":"TPM2 Automatic Unlock","text":"<p>When <code>--tpm2</code> is specified:</p> <ol> <li>TPM2 key is enrolled using <code>systemd-cryptenroll</code></li> <li>No PCR binding is used (empty PCRs = unlock regardless of boot state)</li> <li>The passphrase remains as a backup unlock method</li> <li>Initramfs automatically uses TPM2 to unlock the root partition</li> </ol>"},{"location":"tools/nbc/ENCRYPTION/#why-no-pcr-binding","title":"Why No PCR Binding?","text":"<p>PCR (Platform Configuration Register) binding ties the encryption key to specific boot measurements. While this provides additional security, it can cause lockout when:</p> <ul> <li>Kernel is updated</li> <li>Initramfs is regenerated</li> <li>Bootloader configuration changes</li> <li>Firmware updates occur</li> </ul> <p>By using empty PCRs (<code>--tpm2-pcrs=</code>), the system will unlock as long as:</p> <ul> <li>The TPM2 chip is present</li> <li>The TPM2 state hasn't been reset</li> <li>No tampering is detected</li> </ul> <p>The passphrase always works as a fallback.</p>"},{"location":"tools/nbc/ENCRYPTION/#container-image-requirements","title":"Container Image Requirements","text":"<p>Your bootc container image must include LUKS and TPM2 support in the initramfs.</p>"},{"location":"tools/nbc/ENCRYPTION/#debianubuntu","title":"Debian/Ubuntu","text":"<pre><code>RUN apt-get install -y \\\n    cryptsetup \\\n    cryptsetup-initramfs \\\n    tpm2-tools\n\n# Rebuild initramfs with LUKS support\nRUN update-initramfs -u -k all\n</code></pre> <p>Required packages:</p> <ul> <li><code>cryptsetup</code> - LUKS userspace tools</li> <li><code>cryptsetup-initramfs</code> - LUKS hook for initramfs-tools</li> <li><code>tpm2-tools</code> - TPM2 userspace tools (for TPM2 unlock)</li> <li><code>libtss2-tcti-device0</code> - TPM2 TCTI library (often auto-installed)</li> </ul>"},{"location":"tools/nbc/ENCRYPTION/#fedorarhelcentos","title":"Fedora/RHEL/CentOS","text":"<pre><code>RUN dnf install -y \\\n    cryptsetup \\\n    tpm2-tools \\\n    tpm2-tss\n\n# Dracut should auto-include crypt module\nRUN dracut --force --regenerate-all\n</code></pre> <p>Required packages:</p> <ul> <li><code>cryptsetup</code> - LUKS userspace tools</li> <li><code>tpm2-tools</code> - TPM2 userspace tools</li> <li><code>tpm2-tss</code> - TPM2 software stack</li> </ul> <p>Dracut modules (should be included automatically):</p> <ul> <li><code>90crypt</code> - LUKS support</li> <li><code>91tpm2-tss</code> - TPM2 support</li> </ul>"},{"location":"tools/nbc/ENCRYPTION/#verification","title":"Verification","text":""},{"location":"tools/nbc/ENCRYPTION/#during-installation","title":"During Installation","text":"<p>nbc will check for LUKS/TPM2 support after extracting the container and warn if:</p> <ul> <li>No LUKS initramfs support is detected</li> <li>TPM2 is requested but TPM2 initramfs support is not detected</li> </ul> <p>These are warnings, not errors, since detection is best-effort.</p>"},{"location":"tools/nbc/ENCRYPTION/#after-boot","title":"After Boot","text":"<p>Check encryption status:</p> <pre><code># Verify root is on a LUKS device\nlsblk -f | grep crypt\n\n# Check LUKS header\ncryptsetup luksDump /dev/sdaX\n\n# Verify TPM2 enrollment\nsystemd-cryptenroll --tpm2-device=list /dev/sdaX\n</code></pre>"},{"location":"tools/nbc/ENCRYPTION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tools/nbc/ENCRYPTION/#boot-prompts-for-passphrase-tpm2-not-working","title":"Boot Prompts for Passphrase (TPM2 Not Working)","text":"<ol> <li>Check if TPM2 is available: <code>ls /dev/tpm*</code></li> <li>Verify TPM2 enrollment: <code>systemd-cryptenroll /dev/sdaX</code></li> <li>Check kernel args include <code>rd.luks.options=tpm2-device=auto</code></li> <li>Ensure initramfs has TPM2 support</li> </ol>"},{"location":"tools/nbc/ENCRYPTION/#cannot-boot-after-update","title":"Cannot Boot After Update","text":"<p>If A/B update breaks TPM2 unlock:</p> <ol> <li>Enter passphrase at boot prompt</li> <li>Re-enroll TPM2: <code>systemd-cryptenroll --wipe-slot=tpm2 --tpm2-device=auto /dev/sdaX</code></li> </ol>"},{"location":"tools/nbc/ENCRYPTION/#emergency-recovery","title":"Emergency Recovery","text":"<p>Boot from live media and:</p> <pre><code># Unlock with passphrase\ncryptsetup luksOpen /dev/sdaX root1\n\n# Mount and fix\nmount /dev/mapper/root1 /mnt\n</code></pre>"},{"location":"tools/nbc/ENCRYPTION/#security-considerations","title":"Security Considerations","text":"<ol> <li> <p>Passphrase Strength: Use a strong passphrase. It's your backup when TPM2 fails.</p> </li> <li> <p>Physical Access: Without PCR binding, anyone with physical access to the TPM2 can unlock the system. The security comes from:</p> </li> <li> <p>TPM2 is bound to the specific hardware</p> </li> <li>Removing the disk and attaching to another machine won't work</li> <li> <p>The passphrase is still required without TPM2</p> </li> <li> <p>Recovery Key: Consider adding a recovery key:</p> </li> </ol> <p><code>bash    systemd-cryptenroll --recovery-key /dev/sdaX</code></p> <ol> <li>Remote Unlock: For servers, consider adding network-based unlock (NBDE/Tang).</li> </ol>"},{"location":"tools/nbc/ENCRYPTION/#implementation-details","title":"Implementation Details","text":""},{"location":"tools/nbc/ENCRYPTION/#files-created","title":"Files Created","text":"File Purpose <code>/etc/crypttab</code> Defines LUKS devices for systemd <code>/boot/loader/entries/*.conf</code> Boot entry with LUKS kernel args <code>/boot/grub/grub.cfg</code> GRUB config with LUKS kernel args"},{"location":"tools/nbc/ENCRYPTION/#luks-format-options","title":"LUKS Format Options","text":"<p>nbc uses LUKS2 with default settings:</p> <ul> <li><code>cryptsetup luksFormat --type luks2</code></li> <li>Default cipher (typically <code>aes-xts-plain64</code>)</li> <li>Default key size (typically 256-bit)</li> <li>Default PBKDF (argon2id)</li> </ul>"},{"location":"tools/nbc/ENCRYPTION/#mapper-device-names","title":"Mapper Device Names","text":"Partition Role Mapper Name Root1 (active) <code>root1</code> Root2 (inactive) <code>root2</code> Var <code>var</code> <p>These names are used in:</p> <ul> <li><code>/dev/mapper/&lt;name&gt;</code> paths</li> <li><code>/etc/crypttab</code> entries</li> <li>Kernel command line arguments</li> </ul>"},{"location":"tools/nbc/ENCRYPTION/#system-configuration-storage","title":"System Configuration Storage","text":"<p>Encryption configuration is stored in <code>/var/lib/nbc/state/config.json</code> to support A/B updates:</p> <pre><code>{\n  \"image_ref\": \"ghcr.io/example/image:latest\",\n  \"device\": \"/dev/sda\",\n  \"encryption\": {\n    \"enabled\": true,\n    \"tpm2\": true,\n    \"root1_luks_uuid\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n    \"root2_luks_uuid\": \"yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\",\n    \"var_luks_uuid\": \"zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz\"\n  }\n}\n</code></pre> <p>This configuration is:</p> <ul> <li>Created during install: LUKS UUIDs for all partitions are stored</li> <li>Read during update: Used to generate correct kernel arguments for each root</li> <li>Essential for A/B updates: Each root partition has a different LUKS UUID</li> </ul>"},{"location":"tools/nbc/ENCRYPTION/#ab-updates-with-encryption","title":"A/B Updates with Encryption","text":"<p>When updating an encrypted system, <code>nbc update</code> automatically:</p> <ol> <li>Reads the encryption config from <code>/var/lib/nbc/state/config.json</code></li> <li>Determines which root partition is active and which is the target</li> <li>Generates kernel command lines with the correct LUKS UUIDs:</li> <li>Target root: Uses root1 or root2 LUKS UUID based on which is inactive</li> <li>Previous root: Uses the active root's LUKS UUID for rollback</li> <li>Var partition: Always uses the same var LUKS UUID</li> </ol> <p>Example kernel command line for encrypted target:</p> <pre><code>root=/dev/mapper/root2 rw rd.luks.uuid=&lt;root2-uuid&gt; rd.luks.name=&lt;root2-uuid&gt;=root2 rd.luks.uuid=&lt;var-uuid&gt; rd.luks.name=&lt;var-uuid&gt;=var rd.luks.options=&lt;root2-uuid&gt;=tpm2-device=auto rd.luks.options=&lt;var-uuid&gt;=tpm2-device=auto systemd.mount-extra=/dev/mapper/var:/var:ext4:defaults\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/","title":"/etc Overlay Persistence","text":""},{"location":"tools/nbc/ETC-OVERLAY/#overview","title":"Overview","text":"<p><code>nbc</code> implements an overlay-based persistence mechanism for <code>/etc</code> that allows user modifications to persist across A/B system updates while keeping the base <code>/etc</code> from the container image intact.</p> <p>This approach uses Linux's overlayfs filesystem to layer a writable directory on top of the read-only container <code>/etc</code>, providing:</p> <ul> <li>Persistent user modifications: Changes to <code>/etc</code> survive reboots and A/B updates</li> <li>Clean update path: New container images bring updated <code>/etc</code> without overwriting user changes</li> <li>Conflict detection: Warns when both user and container have modified the same file</li> <li>Automatic setup: Works transparently after installation</li> </ul>"},{"location":"tools/nbc/ETC-OVERLAY/#how-it-works","title":"How It Works","text":""},{"location":"tools/nbc/ETC-OVERLAY/#overlay-structure","title":"Overlay Structure","text":"<pre><code>/etc (merged view seen by the system)\n\u251c\u2500\u2500 lowerdir: /.etc.lower (original /etc from container, read-only)\n\u251c\u2500\u2500 upperdir: /var/lib/nbc/etc-overlay/upper (user modifications, writable)\n\u2514\u2500\u2500 workdir: /var/lib/nbc/etc-overlay/work (overlayfs internal)\n</code></pre> <p>When the system boots:</p> <ol> <li>Installation/Update: <code>nbc</code> populates <code>/.etc.lower</code> with the container's <code>/etc</code></li> <li>Dracut module (<code>95etc-overlay</code>) runs during initramfs, before pivot_root</li> <li>Overlayfs mounts over <code>/etc</code> with <code>/.etc.lower</code> as the lower layer</li> <li>User writes go to <code>/var/lib/nbc/etc-overlay/upper</code></li> <li>Reads see merged view: user modifications overlay container files</li> <li><code>/.etc.lower</code> is hidden by a tmpfs mount to prevent accidental modification</li> </ol>"},{"location":"tools/nbc/ETC-OVERLAY/#kernel-parameters","title":"Kernel Parameters","text":"<p>The overlay is controlled by kernel command-line parameters:</p> Parameter Description <code>rd.etc.overlay=1</code> Enable /etc overlay (required) <code>rd.etc.overlay.var=UUID=xxx</code> /var partition UUID for overlay storage <code>rd.etc.overlay.var=/dev/xxx</code> /var partition device path (alternative) <p>These are automatically added to the bootloader configuration during installation.</p>"},{"location":"tools/nbc/ETC-OVERLAY/#directory-layout","title":"Directory Layout","text":"<p>After installation, the following directories are created on the <code>/var</code> partition:</p> <pre><code>/var/lib/nbc/\n\u251c\u2500\u2500 etc-overlay/\n\u2502   \u251c\u2500\u2500 upper/    # User modifications to /etc (overlayfs upperdir)\n\u2502   \u2514\u2500\u2500 work/     # Overlayfs workdir (internal use)\n\u2514\u2500\u2500 etc.pristine/ # Snapshot of original /etc at install time\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#implementation-details","title":"Implementation Details","text":""},{"location":"tools/nbc/ETC-OVERLAY/#dracut-module","title":"Dracut Module","text":"<p>The overlay is set up by a custom dracut module at <code>/usr/lib/dracut/modules.d/95etc-overlay/</code>:</p> <ul> <li><code>module-setup.sh</code>: Declares dependencies and installs the hook</li> <li><code>etc-overlay-mount.sh</code>: Pre-pivot hook that mounts the overlay</li> </ul> <p>The module runs in the <code>pre-pivot</code> phase, after the root filesystem is mounted but before systemd takes over. This timing is critical because:</p> <ol> <li><code>/var</code> must be mounted first (for overlay storage)</li> <li><code>/etc</code> must not be in use yet (allows moving it to lower layer)</li> <li>Runs before dbus-broker/systemd services need <code>/etc</code></li> </ol>"},{"location":"tools/nbc/ETC-OVERLAY/#installation-process","title":"Installation Process","text":"<p>During <code>nbc install</code>:</p> <ol> <li>Extract container filesystem to root partition</li> <li>Install dracut module to <code>/usr/lib/dracut/modules.d/95etc-overlay/</code></li> <li>Regenerate initramfs to include the module</li> <li>Create overlay directories on <code>/var</code> partition</li> <li>Save pristine <code>/etc</code> snapshot for conflict detection</li> <li>Configure bootloader with <code>rd.etc.overlay=1</code> kernel parameter</li> </ol>"},{"location":"tools/nbc/ETC-OVERLAY/#update-process","title":"Update Process","text":"<p>During <code>nbc update</code>:</p> <ol> <li>Install new container to inactive root partition</li> <li>Install dracut module and regenerate initramfs</li> <li>Overlay directories already exist on shared <code>/var</code></li> <li>Detect conflicts between user modifications and container changes</li> <li>Configure bootloader for new root with overlay parameters</li> </ol> <p>User modifications in <code>/var/lib/nbc/etc-overlay/upper</code> automatically apply to the new root's <code>/etc</code> when overlay mounts at boot.</p>"},{"location":"tools/nbc/ETC-OVERLAY/#runtime-detection","title":"Runtime Detection","text":"<p>A marker file at <code>/run/nbc-booted</code> indicates the system was installed and booted via nbc. This is similar to <code>/run/ostree-booted</code> created by bootc/ostree systems.</p> <p>The marker is created by <code>systemd-tmpfiles</code> during boot via <code>/usr/lib/tmpfiles.d/nbc.conf</code>. This ensures the marker exists after systemd mounts a fresh tmpfs on <code>/run</code> following switch_root.</p>"},{"location":"tools/nbc/ETC-OVERLAY/#shell-script-detection","title":"Shell Script Detection","text":"<pre><code>if [ -f /run/nbc-booted ]; then\n    echo \"Running on nbc-managed system\"\nfi\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#go-code-detection","title":"Go Code Detection","text":"<p>The <code>pkg</code> package provides a helper function:</p> <pre><code>import \"github.com/frostyard/nbc/pkg\"\n\nif pkg.IsNBCBooted() {\n    // System was booted via nbc\n    fmt.Println(\"nbc-managed system detected\")\n}\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#programmatic-use-cases","title":"Programmatic Use Cases","text":"<ul> <li>Conditionally enable/disable features based on boot method</li> <li>Detect whether A/B updates are available</li> <li>Validate that nbc dracut module ran successfully</li> <li>System inventory and management tools</li> </ul>"},{"location":"tools/nbc/ETC-OVERLAY/#conflict-detection","title":"Conflict Detection","text":"<p>When updating, <code>nbc</code> compares:</p> <ul> <li>Files in overlay upper (user-modified files)</li> <li>Files in new container's <code>/etc</code></li> <li>Files in pristine <code>/etc</code> snapshot from previous installation</li> </ul> <p>A conflict is detected when:</p> <ul> <li>A file exists in the overlay upper (user modified it), AND</li> <li>The same file differs between pristine and new container (container updated it)</li> </ul> <p>Conflicts are reported but user modifications take precedence. The overlay upper layer always wins, meaning container updates to conflicting files are hidden.</p> <pre><code>Warning: Potential conflicts detected (files modified by both user and update):\n  ! resolv.conf\n  ! hostname\nUser modifications in overlay will take precedence over container changes.\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#requirements","title":"Requirements","text":""},{"location":"tools/nbc/ETC-OVERLAY/#container-image-requirements","title":"Container Image Requirements","text":"<ul> <li>dracut: Must be installed at <code>/usr/bin/dracut</code> or <code>/sbin/dracut</code></li> <li>overlay kernel module: Modern Linux kernels include this by default</li> </ul>"},{"location":"tools/nbc/ETC-OVERLAY/#filesystem-requirements","title":"Filesystem Requirements","text":"<ul> <li><code>/var</code> partition must be mountable during initramfs (before pivot_root)</li> <li>Supports ext4 and btrfs filesystems for <code>/var</code></li> </ul>"},{"location":"tools/nbc/ETC-OVERLAY/#building-images-with-pre-included-etc-overlay-module","title":"Building Images with Pre-included etc-overlay Module","text":"<p>Container image authors can include the etc-overlay dracut module and pre-build the initramfs in their images. This speeds up installation and updates by skipping the initramfs regeneration step.</p>"},{"location":"tools/nbc/ETC-OVERLAY/#benefits","title":"Benefits","text":"<ul> <li>Faster installation: No need to run dracut during install/update</li> <li>Smaller runtime footprint: No need to include dracut in the final image (if pre-built)</li> <li>Reproducible builds: Initramfs is built once in CI, not on each target machine</li> <li>Offline installation: No dracut execution required on the target system</li> </ul>"},{"location":"tools/nbc/ETC-OVERLAY/#option-1-install-nbc-package-recommended","title":"Option 1: Install nbc Package (Recommended)","text":"<p>The simplest approach is to install the <code>nbc</code> package in your container image. This installs the dracut module and regenerates the initramfs automatically.</p> <pre><code>FROM ghcr.io/frostyard/debian-bootc:trixie\n\n# Install nbc - this installs the dracut module to\n# /usr/lib/dracut/modules.d/95etc-overlay/\nRUN apt-get update &amp;&amp; apt-get install -y nbc\n\n# Regenerate initramfs for all kernels with etc-overlay included\nRUN for kver in /usr/lib/modules/*/; do \\\n      kver=$(basename \"$kver\"); \\\n      dracut --force --add etc-overlay \\\n        /usr/lib/modules/$kver/initramfs.img $kver; \\\n    done\n\n# Optional: Remove dracut to reduce image size (initramfs already built)\n# Only do this if you won't need to regenerate initramfs later\n# RUN apt-get remove -y dracut-core &amp;&amp; apt-get autoremove -y\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#option-2-copy-dracut-module-manually","title":"Option 2: Copy Dracut Module Manually","text":"<p>If you don't want to install the full nbc package, you can copy just the dracut module files:</p> <pre><code>FROM ghcr.io/frostyard/debian-bootc:trixie\n\n# Copy the dracut module from nbc source or a built nbc image\nCOPY --from=ghcr.io/frostyard/nbc:latest \\\n  /usr/lib/dracut/modules.d/95etc-overlay \\\n  /usr/lib/dracut/modules.d/95etc-overlay\n\n# Regenerate initramfs with the module\nRUN for kver in /usr/lib/modules/*/; do \\\n      kver=$(basename \"$kver\"); \\\n      dracut --force --add etc-overlay \\\n        /usr/lib/modules/$kver/initramfs.img $kver; \\\n    done\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#option-3-build-module-from-source","title":"Option 3: Build Module from Source","text":"<p>For maximum control, embed the module files directly in your Dockerfile:</p> <pre><code>FROM ghcr.io/frostyard/debian-bootc:trixie\n\n# Create the dracut module directory\nRUN mkdir -p /usr/lib/dracut/modules.d/95etc-overlay\n\n# Create module-setup.sh\nRUN cat &gt; /usr/lib/dracut/modules.d/95etc-overlay/module-setup.sh &lt;&lt; 'EOF'\n#!/bin/bash\ncheck() { return 0; }\ndepends() { echo \"rootfs-block\"; return 0; }\ninstall() {\n    inst_hook pre-pivot 50 \"$moddir/etc-overlay-mount.sh\"\n    inst_multiple mount umount mkdir\n}\ninstallkernel() { instmods overlay; }\nEOF\n\n# Create etc-overlay-mount.sh (the actual hook script)\n# See pkg/dracut/95etc-overlay/etc-overlay-mount.sh for full content\nCOPY etc-overlay-mount.sh /usr/lib/dracut/modules.d/95etc-overlay/\n\n# Make scripts executable\nRUN chmod +x /usr/lib/dracut/modules.d/95etc-overlay/*.sh\n\n# Regenerate initramfs\nRUN for kver in /usr/lib/modules/*/; do \\\n      kver=$(basename \"$kver\"); \\\n      dracut --force --add etc-overlay \\\n        /usr/lib/modules/$kver/initramfs.img $kver; \\\n    done\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#verifying-the-initramfs","title":"Verifying the Initramfs","text":"<p>After building your image, verify the initramfs includes the etc-overlay module:</p> <pre><code># Inside the container or on extracted image\nlsinitrd /usr/lib/modules/$(uname -r)/initramfs.img | grep etc-overlay\n\n# Should show something like:\n# usr/lib/dracut/hooks/pre-pivot/50etc-overlay-mount.sh\n</code></pre> <p>Or use <code>lsinitramfs</code> on Debian-based systems:</p> <pre><code>lsinitramfs /usr/lib/modules/*/initramfs.img | grep etc-overlay\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#cicd-integration","title":"CI/CD Integration","text":"<p>Example GitHub Actions workflow to verify initramfs:</p> <pre><code>- name: Verify initramfs includes etc-overlay\n  run: |\n    # Extract and check the image\n    podman create --name temp ${{ env.IMAGE_NAME }}\n    podman cp temp:/usr/lib/modules - | tar -tf - | grep -q initramfs.img\n\n    # Check initramfs contents\n    podman run --rm ${{ env.IMAGE_NAME }} \\\n      lsinitramfs /usr/lib/modules/*/initramfs.img | grep -q etc-overlay-mount.sh\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#nbc-behavior-with-pre-built-initramfs","title":"nbc Behavior with Pre-built Initramfs","text":"<p>When nbc detects that an initramfs already contains the etc-overlay module, it skips regeneration:</p> <pre><code>  Checking initramfs for etc-overlay module...\n    \u2713 Initramfs for 6.12.0-1-amd64 already has etc-overlay module\n  All initramfs images already have etc-overlay module, skipping regeneration\n</code></pre> <p>This check uses <code>lsinitrd</code> (Fedora/RHEL) or <code>lsinitramfs</code> (Debian/Ubuntu) to inspect the initramfs contents without extracting them.</p>"},{"location":"tools/nbc/ETC-OVERLAY/#caveats-and-limitations","title":"Caveats and Limitations","text":""},{"location":"tools/nbc/ETC-OVERLAY/#read-only-root-filesystem","title":"Read-Only Root Filesystem","text":"<p>The root filesystem is mounted read-only (<code>ro</code>) for immutability, similar to how bootc/ostree systems work. This provides:</p> <ul> <li>Protection from accidental modifications: System files cannot be altered</li> <li>Atomic updates: The entire root is replaced during A/B updates</li> <li>Reproducibility: The root filesystem always matches the container image</li> </ul> <p>The <code>/etc</code> overlay allows user configuration to persist despite the read-only root.</p>"},{"location":"tools/nbc/ETC-OVERLAY/#how-the-overlay-works-with-read-only-root","title":"How the Overlay Works with Read-Only Root","text":"<p>During early boot, the dracut etc-overlay module:</p> <ol> <li>Temporarily remounts root read-write</li> <li>Moves <code>/etc</code> to <code>/.etc.lower</code> (the overlay lower layer)</li> <li>Mounts the overlay on <code>/etc</code></li> <li>Remounts root back to read-only</li> </ol> <p>This ensures <code>/etc</code> modifications work while the rest of root stays immutable.</p>"},{"location":"tools/nbc/ETC-OVERLAY/#etcmachine-id-handling","title":"/etc/machine-id Handling","text":"<p>For read-only root to work with systemd's first-boot detection:</p> <ul> <li>nbc pre-populates <code>/etc/machine-id</code> with \"uninitialized\" during installation</li> <li>On first boot, systemd detects this and generates a real machine-id</li> <li>The generated machine-id is written to the overlay upper layer (on <code>/var</code>)</li> <li>Subsequent boots read the machine-id from the overlay</li> </ul> <p>Important: Container images should NOT have a populated <code>/etc/machine-id</code>. Use <code>nbc lint</code> to detect and fix this issue.</p>"},{"location":"tools/nbc/ETC-OVERLAY/#first-boot-behavior","title":"First Boot Behavior","text":"<p>On first boot:</p> <ul> <li>Overlay directories are created automatically if missing</li> <li><code>/.etc.lower</code> contains the container's <code>/etc</code> (populated during install/update)</li> <li>System generates <code>/etc/machine-id</code> (written to overlay upper)</li> </ul>"},{"location":"tools/nbc/ETC-OVERLAY/#hidden-lower-layer","title":"Hidden Lower Layer","text":"<p>The container's <code>/etc</code> at <code>/.etc.lower</code> is hidden by an empty tmpfs mount to:</p> <ul> <li>Prevent confusion from seeing duplicate <code>/etc</code> contents</li> <li>Avoid accidental modifications to the read-only layer</li> </ul> <p>To inspect the lower layer, unmount the hiding tmpfs:</p> <pre><code>umount /.etc.lower\nls /.etc.lower/\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#overlay-upper-layer-persistence","title":"Overlay Upper Layer Persistence","text":"<p>The upper layer persists indefinitely. Old modifications are never automatically cleaned. To \"reset\" <code>/etc</code> to container defaults:</p> <pre><code># WARNING: This removes ALL user /etc modifications\nrm -rf /var/lib/nbc/etc-overlay/upper/*\nrm -rf /var/lib/nbc/etc-overlay/work/*\nreboot\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#files-that-may-cause-issues","title":"Files That May Cause Issues","text":"<p>Some files in <code>/etc</code> have special considerations:</p> File Consideration <code>/etc/machine-id</code> Generated on first boot, persists in overlay <code>/etc/fstab</code> Created by nbc, user modifications persist <code>/etc/passwd</code>, <code>/etc/group</code> User additions persist, container updates may conflict <code>/etc/shadow</code> User password changes persist <code>/etc/resolv.conf</code> Network config, may be overwritten by NetworkManager"},{"location":"tools/nbc/ETC-OVERLAY/#ab-update-compatibility","title":"A/B Update Compatibility","text":"<p>The overlay is shared between A and B root partitions via the common <code>/var</code> partition. This means:</p> <ul> <li>User modifications apply to whichever root is active</li> <li>Rolling back to previous root still sees current <code>/etc</code> modifications</li> <li>To truly roll back <code>/etc</code>, manually restore from pristine snapshot</li> </ul>"},{"location":"tools/nbc/ETC-OVERLAY/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tools/nbc/ETC-OVERLAY/#check-if-system-booted-via-nbc","title":"Check if System Booted via nbc","text":"<pre><code># Check for runtime marker\nif [ -f /run/nbc-booted ]; then\n    echo \"nbc-managed boot detected\"\nelse\n    echo \"Not an nbc-managed boot\"\nfi\n</code></pre> <p>If <code>/run/nbc-booted</code> doesn't exist but overlay is mounted, the dracut module may have partially failed.</p>"},{"location":"tools/nbc/ETC-OVERLAY/#check-if-overlay-is-active","title":"Check if Overlay is Active","text":"<pre><code># Should show overlay mount on /etc\nmount | grep 'overlay on /etc'\n\n# Check kernel parameters\ngrep 'rd.etc.overlay' /proc/cmdline\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#verify-overlay-directories","title":"Verify Overlay Directories","text":"<pre><code># Check upper layer content\nls -la /var/lib/nbc/etc-overlay/upper/\n\n# Count user-modified files\nfind /var/lib/nbc/etc-overlay/upper -type f | wc -l\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#check-lower-layer-hidden","title":"Check Lower Layer (Hidden)","text":"<pre><code># Unmount the hiding tmpfs\numount /.etc.lower\n\n# Inspect original /etc from container\nls /.etc.lower/\n\n# Re-hide (or just reboot)\nmount -t tmpfs -o size=0,mode=000 tmpfs /.etc.lower\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#overlay-not-mounting","title":"Overlay Not Mounting","text":"<p>If <code>/etc</code> is not an overlay after boot:</p> <ol> <li>Check kernel cmdline: <code>cat /proc/cmdline | grep rd.etc.overlay</code></li> <li>Check dracut module: <code>ls /usr/lib/dracut/modules.d/95etc-overlay/</code></li> <li>Check initramfs includes module: <code>lsinitrd | grep etc-overlay</code></li> <li>Check dmesg for overlay errors: <code>dmesg | grep -i overlay</code></li> </ol>"},{"location":"tools/nbc/ETC-OVERLAY/#regenerate-initramfs","title":"Regenerate Initramfs","text":"<p>If the dracut module is present but not in initramfs:</p> <pre><code># Find kernel version\nKVER=$(uname -r)\n\n# Regenerate with etc-overlay module\ndracut --force --add etc-overlay /boot/initramfs-$KVER.img $KVER\n</code></pre>"},{"location":"tools/nbc/ETC-OVERLAY/#implementation-files","title":"Implementation Files","text":"File Purpose <code>pkg/dracut/95etc-overlay/module-setup.sh</code> Dracut module definition <code>pkg/dracut/95etc-overlay/etc-overlay-mount.sh</code> Pre-pivot hook script <code>pkg/dracut.go</code> Installs dracut module, regenerates initramfs <code>pkg/etc_persistence.go</code> Creates overlay directories, conflict detection <code>pkg/bootloader.go</code> Adds kernel parameters for overlay"},{"location":"tools/nbc/IMPLEMENTATION/","title":"Implementation Summary","text":""},{"location":"tools/nbc/IMPLEMENTATION/#overview","title":"Overview","text":"<p>Successfully refactored <code>nbc</code> to perform bootc-compatible container installations without using the external <code>bootc</code> command. The application now handles all installation steps natively in Go.</p>"},{"location":"tools/nbc/IMPLEMENTATION/#architecture","title":"Architecture","text":""},{"location":"tools/nbc/IMPLEMENTATION/#core-components","title":"Core Components","text":"<ol> <li> <p>pkg/partition.go - Disk partitioning and formatting</p> </li> <li> <p>GPT partition table creation with <code>sgdisk</code></p> </li> <li>EFI (2GB FAT32), Boot (1GB ext4), Root1 (12GB ext4), Root2 (12GB ext4), Var (remaining ext4)</li> <li>A/B partition scheme for atomic updates</li> <li> <p>Partition mounting and UUID management</p> </li> <li> <p>pkg/container.go - Container filesystem extraction</p> </li> <li> <p>Extracts container images using go-containerregistry (pure Go, no Docker/Podman required)</p> </li> <li>Handles overlay filesystem whiteouts for proper layer merging</li> <li>Preserves SUID/SGID/sticky bits on files and directories</li> <li>Creates system directories and fstab with systemd auto-discovery</li> <li> <p>Supports chroot operations for post-install configuration</p> </li> <li> <p>pkg/bootloader.go - Bootloader installation</p> </li> <li> <p>GRUB2 and systemd-boot support (with automatic detection)</p> </li> <li>Copies kernels/initramfs from /usr/lib/modules to appropriate boot location</li> <li>Configures kernel cmdline with root=UUID and systemd.mount-extra for /var</li> <li>Generates bootloader configuration files</li> <li>Kernel argument customization</li> <li> <p>Secure Boot support: Automatic shim detection and EFI chain setup</p> <ul> <li>Searches for <code>shimx64.efi.signed</code> in common locations</li> <li>Sets up proper boot chain: shim \u2192 bootloader</li> <li>Includes MOK manager for key enrollment</li> </ul> </li> <li> <p>pkg/bootc.go - Main installation orchestrator</p> </li> <li> <p>Coordinates all installation steps</p> </li> <li>Provides progress feedback</li> <li> <p>Handles cleanup on errors</p> </li> <li> <p>pkg/disk.go - Disk management utilities</p> </li> <li>Disk discovery and enumeration</li> <li>Validation and safety checks</li> <li>Support for SATA, NVMe, virtio, MMC devices</li> </ol>"},{"location":"tools/nbc/IMPLEMENTATION/#installation-process","title":"Installation Process","text":"<p>The complete installation workflow (6 steps):</p> <pre><code>1. Create Partitions\n   \u2514\u2500 sgdisk creates GPT with EFI/boot/root1/root2/var partitions\n      \u251c\u2500 EFI: 2GB (ESP partition type, auto-mounted by systemd)\n      \u251c\u2500 Boot: 1GB (XBOOTLDR partition type, auto-mounted by systemd)\n      \u251c\u2500 Root1: 12GB (active root for OS A)\n      \u251c\u2500 Root2: 12GB (inactive root for OS B, for A/B updates)\n      \u2514\u2500 Var: remaining space (mounted via systemd.mount-extra)\n\n2. Format Partitions\n   \u251c\u2500 mkfs.vfat for EFI (FAT32)\n   \u251c\u2500 mkfs.ext4 for boot, root1, root2, var\n   \u2514\u2500 Retrieve UUIDs with blkid\n\n3. Mount Partitions\n   \u251c\u2500 Mount root1 \u2192 /tmp/nbc-install\n   \u251c\u2500 Mount boot \u2192 /tmp/nbc-install/boot\n   \u251c\u2500 Mount EFI \u2192 /tmp/nbc-install/boot/efi\n   \u2514\u2500 Mount var \u2192 /tmp/nbc-install/var\n\n4. Extract Container\n   \u251c\u2500 Pull image layers via go-containerregistry\n   \u251c\u2500 Extract each layer handling whiteouts\n   \u251c\u2500 Preserve special file permissions (SUID/SGID)\n   \u2514\u2500 Extract filesystem to mounted root1\n\n5. Configure System\n   \u251c\u2500 Create /etc/fstab (minimal, most mounts auto-discovered)\n   \u251c\u2500 Setup system directories (dev, proc, sys, run, tmp)\n   \u251c\u2500 Setup /etc overlay for persistence across A/B updates\n   \u2502  \u251c\u2500 Create /var/lib/nbc/etc-overlay/{upper,work} directories\n   \u2502  \u2514\u2500 Install dracut module (95etc-overlay) for overlay mount\n   \u2514\u2500 Parse os-release for OS name\n\n   Note: /etc persistence uses overlayfs with the container's /etc\n   as lowerdir and /var/lib/nbc/etc-overlay as upperdir. The overlay\n   is mounted by a dracut module during initramfs phase (pre-pivot).\n   User modifications are stored in the upperdir on /var and persist\n   across A/B updates. See docs/ETC-OVERLAY.md for details.\n\n6. Install Bootloader\n   \u251c\u2500 Detect bootloader type (GRUB2/systemd-boot)\n   \u251c\u2500 Copy kernel/initramfs from /usr/lib/modules\n   \u251c\u2500 Install bootloader to EFI partition\n   \u251c\u2500 Setup Secure Boot chain (if shim available):\n   \u2502  \u251c\u2500 Copy shimx64.efi as BOOTX64.EFI\n   \u2502  \u251c\u2500 Copy bootloader as grubx64.efi (chain-loaded by shim)\n   \u2502  \u2514\u2500 Copy mmx64.efi for MOK key enrollment\n   \u251c\u2500 Generate boot configuration with:\n   \u2502  \u251c\u2500 root=UUID=&lt;root1-uuid&gt;\n   \u2502  \u2514\u2500 systemd.mount-extra=UUID=&lt;var-uuid&gt;:/var:ext4:defaults\n   \u2514\u2500 Set proper kernel cmdline arguments\n</code></pre>"},{"location":"tools/nbc/IMPLEMENTATION/#key-features","title":"Key Features","text":""},{"location":"tools/nbc/IMPLEMENTATION/#no-external-dependencies","title":"No External Dependencies","text":"<ul> <li>All functionality implemented natively in Go</li> <li>Uses go-containerregistry (no Docker/Podman required)</li> <li>Uses standard Linux tools (sgdisk, mkfs, mount, grub/bootctl)</li> <li>More transparent and maintainable</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#safety-features","title":"Safety Features","text":"<ul> <li>Comprehensive prerequisite checking</li> <li>Mounted partition detection</li> <li>Confirmation prompts before destructive operations</li> <li>Dry-run mode for testing</li> <li>Automatic cleanup on errors</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#flexibility","title":"Flexibility","text":"<ul> <li>Multiple device type support (SATA, NVMe, virtio, MMC, loop devices)</li> <li>A/B partition scheme for atomic updates</li> <li>Custom kernel arguments</li> <li>Automatic bootloader detection (GRUB2 vs systemd-boot)</li> <li>Systemd Discoverable Partitions integration</li> <li>Configurable mount points</li> <li>Filesystem choice: ext4 (default) or btrfs for root/var partitions</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#user-experience","title":"User Experience","text":"<ul> <li>Clear progress indicators (Step X/6)</li> <li>Verbose output option for debugging</li> <li>Detailed error messages</li> <li>Post-installation verification</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#usage-examples","title":"Usage Examples","text":""},{"location":"tools/nbc/IMPLEMENTATION/#basic-installation","title":"Basic Installation","text":"<pre><code>sudo ./nbc install \\\n  --image quay.io/fedora/fedora-coreos:stable \\\n  --device /dev/sda\n</code></pre>"},{"location":"tools/nbc/IMPLEMENTATION/#with-custom-kernel-args","title":"With Custom Kernel Args","text":"<pre><code>sudo ./nbc install \\\n  --image localhost/custom-image \\\n  --device /dev/nvme0n1 \\\n  --karg console=ttyS0 \\\n  --karg quiet\n</code></pre>"},{"location":"tools/nbc/IMPLEMENTATION/#dry-run-test","title":"Dry Run Test","text":"<pre><code>./nbc install \\\n  --image test/image \\\n  --device /dev/sdb \\\n  --dry-run\n</code></pre>"},{"location":"tools/nbc/IMPLEMENTATION/#technical-improvements","title":"Technical Improvements","text":""},{"location":"tools/nbc/IMPLEMENTATION/#removed-dependencies","title":"Removed Dependencies","text":"<ul> <li>\u274c bootc command not required</li> <li>\u274c Docker/Podman not required (uses go-containerregistry directly)</li> <li>\u2705 Uses standard Linux utilities only</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#added-functionality","title":"Added Functionality","text":"<ul> <li>\u2705 Direct GPT partitioning with A/B update scheme</li> <li>\u2705 Filesystem creation and mounting</li> <li>\u2705 Container extraction via go-containerregistry (pure Go)</li> <li>\u2705 Overlay filesystem whiteout handling</li> <li>\u2705 Native bootloader installation (GRUB2 and systemd-boot)</li> <li>\u2705 System configuration (fstab, directories)</li> <li>\u2705 Systemd Discoverable Partitions support</li> <li>\u2705 Kernel cmdline generation with systemd.mount-extra</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#code-organization","title":"Code Organization","text":"<ul> <li>Modular package structure</li> <li>Clear separation of concerns</li> <li>Reusable components</li> <li>Comprehensive error handling</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#testing-recommendations","title":"Testing Recommendations","text":"<ol> <li>Virtual Machine Testing</li> </ol> <p><code>bash    # Create a test VM with extra disk    # Test with various container images    sudo ./nbc install --image &lt;test-image&gt; --device /dev/vdb</code></p> <ol> <li>Dry Run Validation</li> </ol> <p><code>bash    # Verify workflow without changes    ./nbc install --image &lt;image&gt; --device /dev/sdX --dry-run</code></p> <ol> <li>Different Device Types</li> <li>Test on SATA devices (/dev/sda)</li> <li>Test on NVMe devices (/dev/nvme0n1)</li> <li>Test on virtio devices (/dev/vda)</li> </ol>"},{"location":"tools/nbc/IMPLEMENTATION/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements:</p> <ul> <li>[x] A/B partition scheme (implemented)</li> <li>[x] systemd-boot support (implemented)</li> <li>[x] /etc persistence via overlayfs (implemented)</li> <li>[ ] Support for custom partition layouts</li> <li>[ ] BTRFS/XFS filesystem options</li> <li>[ ] RAID/LVM support</li> <li>[ ] Encrypted root filesystem</li> <li>[ ] Multi-boot configurations</li> <li>[ ] Progress bars for long operations</li> <li>[ ] Automatic A/B updates</li> <li>[ ] Rollback capability</li> <li>[ ] Pre/post installation hooks</li> <li>[x] Secure Boot support (implemented)</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#files-modifiedcreated","title":"Files Modified/Created","text":"<p>New Files:</p> <ul> <li><code>pkg/partition.go</code> - Partitioning logic</li> <li><code>pkg/container.go</code> - Container extraction</li> <li><code>pkg/bootloader.go</code> - Bootloader installation</li> </ul> <p>Modified Files:</p> <ul> <li><code>pkg/bootc.go</code> - Complete rewrite of Install() method</li> <li><code>README.md</code> - Updated documentation</li> </ul> <p>Unchanged Files:</p> <ul> <li><code>pkg/disk.go</code> - Disk management utilities</li> <li><code>cmd/*.go</code> - CLI commands</li> <li><code>main.go</code> - Entry point</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#dependencies","title":"Dependencies","text":""},{"location":"tools/nbc/IMPLEMENTATION/#required-tools","title":"Required Tools","text":"<ul> <li><code>go-containerregistry</code> (embedded) - Container image operations</li> <li><code>sgdisk</code> - GPT partitioning</li> <li><code>mkfs.vfat</code> - FAT32 formatting (EFI partition)</li> <li><code>mkfs.ext4</code> - ext4 formatting (boot, root, var partitions)</li> <li><code>mount/umount</code> - Filesystem mounting</li> <li><code>blkid</code> - UUID retrieval</li> <li><code>partprobe</code> - Kernel partition update</li> <li><code>udevadm</code> - Device node synchronization</li> <li><code>grub-install</code> or <code>grub2-install</code> - GRUB bootloader (if using GRUB)</li> <li><code>bootctl</code> - systemd-boot bootloader (if using systemd-boot)</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#go-packages","title":"Go Packages","text":"<ul> <li><code>github.com/spf13/cobra</code> - CLI framework</li> <li><code>github.com/spf13/viper</code> - Configuration</li> <li><code>github.com/google/go-containerregistry</code> - Container image handling</li> <li>Standard library for core logic (os, os/exec, archive/tar, path/filepath)</li> </ul>"},{"location":"tools/nbc/IMPLEMENTATION/#conclusion","title":"Conclusion","text":"<p>The <code>nbc</code> tool provides a complete, self-contained solution for installing bootc-compatible containers to physical disks with A/B partition scheme for atomic updates. It eliminates dependencies on external tools like bootc, Docker, or Podman by using native Go libraries (go-containerregistry) and standard Linux utilities. The implementation leverages systemd Discoverable Partitions for automatic mounting and provides a foundation for robust, atomic OS updates.</p>"},{"location":"tools/nbc/INCUS-TESTS/","title":"Incus Integration Testing","text":"<p>This document describes the Incus-based integration testing for nbc.</p>"},{"location":"tools/nbc/INCUS-TESTS/#overview","title":"Overview","text":"<p>The Incus test suite (<code>test_incus.sh</code>) provides comprehensive end-to-end testing in isolated virtual machines. Unlike loop device tests, Incus tests run in real VMs with actual bootloaders and complete system environments.</p>"},{"location":"tools/nbc/INCUS-TESTS/#prerequisites","title":"Prerequisites","text":""},{"location":"tools/nbc/INCUS-TESTS/#install-incus","title":"Install Incus","text":"<pre><code># Ubuntu/Debian (from package)\nsudo apt install incus\n\n# Or use snap\nsudo snap install incus\n\n# Or build from source\n# See: https://linuxcontainers.org/incus/docs/main/installing/\n</code></pre>"},{"location":"tools/nbc/INCUS-TESTS/#initialize-incus","title":"Initialize Incus","text":"<pre><code>sudo incus admin init\n</code></pre> <p>For testing, you can use the default answers for most questions. Ensure you have:</p> <ul> <li>Default storage pool (ZFS, btrfs, or dir)</li> <li>Network bridge configured</li> <li>At least 10GB free storage</li> </ul>"},{"location":"tools/nbc/INCUS-TESTS/#running-tests","title":"Running Tests","text":"<pre><code># Run all Incus integration tests (recommended)\nsudo make test-incus\n\n# Or run the script directly with preserved PATH\nsudo -E env \"PATH=$PATH\" ./test_incus.sh\n\n# Use a custom/private container image\nTEST_IMAGE=ghcr.io/myorg/myimage:latest sudo -E ./test_incus.sh\n</code></pre> <p>Important: The test requires <code>go</code> and <code>make</code> to be in PATH. The Makefile target automatically preserves your PATH when running with sudo. If running the script directly, use <code>sudo -E env \"PATH=$PATH\"</code> to ensure all tools are available.</p>"},{"location":"tools/nbc/INCUS-TESTS/#using-private-container-images","title":"Using Private Container Images","text":"<p>By default, tests use <code>quay.io/centos-bootc/centos-bootc:stream9</code> (public image).</p> <p>To test with a private image:</p> <ol> <li>Login to the registry:</li> </ol> <p><code>bash    docker login ghcr.io    # or    podman login ghcr.io</code></p> <ol> <li>Run tests with your image:    <code>bash    TEST_IMAGE=ghcr.io/myorg/myimage:latest sudo -E ./test_incus.sh</code></li> </ol> <p>The test will use credentials from <code>~/.docker/config.json</code> automatically.</p>"},{"location":"tools/nbc/INCUS-TESTS/#what-gets-tested","title":"What Gets Tested","text":"<p>The Incus integration test performs the following tests:</p>"},{"location":"tools/nbc/INCUS-TESTS/#1-list-disks","title":"1. List Disks","text":"<p>Verifies <code>nbc list</code> can discover available disks in the VM.</p>"},{"location":"tools/nbc/INCUS-TESTS/#2-validate-disk","title":"2. Validate Disk","text":"<p>Tests <code>nbc validate</code> correctly identifies suitable installation targets.</p>"},{"location":"tools/nbc/INCUS-TESTS/#3-install-to-disk","title":"3. Install to Disk","text":"<p>Performs a complete bootc image installation:</p> <ul> <li>Creates 5-partition GPT layout (EFI, boot, root1, root2, var)</li> <li>Extracts container filesystem</li> <li>Installs GRUB2 bootloader</li> <li>Configures fstab and system files</li> </ul>"},{"location":"tools/nbc/INCUS-TESTS/#4-verify-partition-layout","title":"4. Verify Partition Layout","text":"<p>Checks that exactly 5 partitions are created with correct labels and sizes.</p>"},{"location":"tools/nbc/INCUS-TESTS/#5-verify-bootloader","title":"5. Verify Bootloader","text":"<p>Validates:</p> <ul> <li>GRUB installation to EFI partition</li> <li>Boot partition contents</li> <li>GRUB configuration file</li> </ul>"},{"location":"tools/nbc/INCUS-TESTS/#6-verify-root-filesystem","title":"6. Verify Root Filesystem","text":"<p>Inspects the installed root filesystem:</p> <ul> <li>Directory structure</li> <li>Nbc configuration file</li> <li>fstab entries</li> <li>Symlinks to /var</li> </ul>"},{"location":"tools/nbc/INCUS-TESTS/#7-system-update","title":"7. System Update","text":"<p>Performs an A/B update:</p> <ul> <li>Pulls new image</li> <li>Installs to inactive partition (root2)</li> <li>Merges user /etc modifications from active root to new root</li> <li>Updates bootloader</li> </ul>"},{"location":"tools/nbc/INCUS-TESTS/#8-verify-ab-partitions","title":"8. Verify A/B Partitions","text":"<p>Confirms both root partitions contain valid filesystems after update.</p>"},{"location":"tools/nbc/INCUS-TESTS/#9-verify-grub-boot-entries","title":"9. Verify GRUB Boot Entries","text":"<p>Checks GRUB menu has entries for both systems (updated and previous).</p>"},{"location":"tools/nbc/INCUS-TESTS/#10-verify-kernel-and-initramfs","title":"10. Verify Kernel and Initramfs","text":"<p>Validates kernel and initramfs are properly installed in /boot partition.</p>"},{"location":"tools/nbc/INCUS-TESTS/#test-environment","title":"Test Environment","text":"<p>Each test run:</p> <ul> <li>Creates a fresh Fedora 40 VM</li> <li>Attaches a 60GB virtual disk</li> <li>Installs required tools (grub2, gdisk, etc.)</li> <li>Copies nbc binary to VM</li> <li>Runs all tests</li> <li>Cleans up VM and resources automatically</li> </ul>"},{"location":"tools/nbc/INCUS-TESTS/#test-duration","title":"Test Duration","text":"<p>Typical test run takes 10-20 minutes depending on:</p> <ul> <li>Network speed (image downloads)</li> <li>Disk I/O performance</li> <li>CPU speed (image extraction, filesystem operations)</li> </ul>"},{"location":"tools/nbc/INCUS-TESTS/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tools/nbc/INCUS-TESTS/#incus-command-not-found","title":"\"incus: command not found\"","text":"<p>Install Incus following the official documentation.</p>"},{"location":"tools/nbc/INCUS-TESTS/#error-incus-is-not-initialized","title":"\"Error: Incus is not initialized\"","text":"<p>Run <code>sudo incus admin init</code> to set up Incus storage and networking.</p>"},{"location":"tools/nbc/INCUS-TESTS/#error-vm-failed-to-start","title":"\"Error: VM failed to start\"","text":"<p>Check Incus logs:</p> <pre><code>incus info nbc-test-&lt;PID&gt; --show-log\n</code></pre> <p>Ensure your system supports KVM virtualization:</p> <pre><code># Check for KVM support\nlsmod | grep kvm\n\n# If missing, load KVM module\nsudo modprobe kvm\nsudo modprobe kvm_intel  # or kvm_amd\n</code></pre>"},{"location":"tools/nbc/INCUS-TESTS/#test-timeout","title":"Test timeout","text":"<p>If tests timeout, increase the timeout value in <code>test_incus.sh</code>:</p> <pre><code>TIMEOUT=1800  # 30 minutes\n</code></pre>"},{"location":"tools/nbc/INCUS-TESTS/#insufficient-storage","title":"Insufficient storage","text":"<p>Incus needs space for:</p> <ul> <li>VM image (2-3 GB)</li> <li>Virtual disk (60 GB)</li> <li>Container image (2-5 GB)</li> </ul> <p>Ensure your storage pool has at least 70 GB free:</p> <pre><code>incus storage info default\n</code></pre>"},{"location":"tools/nbc/INCUS-TESTS/#log-files","title":"Log Files","text":"<p>Failed tests save logs to <code>/tmp</code>:</p> <ul> <li><code>/tmp/nbc-install-&lt;PID&gt;.log</code> - Installation log</li> <li><code>/tmp/nbc-update-&lt;PID&gt;.log</code> - Update log</li> </ul>"},{"location":"tools/nbc/INCUS-TESTS/#cleanup","title":"Cleanup","text":"<p>The test script automatically cleans up:</p> <ul> <li>Stops and deletes VMs</li> <li>Removes storage volumes</li> <li>Deletes temporary build directories</li> </ul> <p>Manual cleanup if needed:</p> <pre><code># List VMs\nincus list\n\n# Delete stuck VM\nincus delete nbc-test-&lt;PID&gt; --force\n\n# List and delete storage volumes\nincus storage volume list default\nincus storage volume delete default nbc-test-&lt;PID&gt;-disk\n</code></pre>"},{"location":"tools/nbc/INCUS-TESTS/#cicd-integration","title":"CI/CD Integration","text":"<p>To run Incus tests in CI:</p> <pre><code># GitHub Actions example\ntest-incus:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v4\n    - name: Install Incus\n      run: |\n        sudo snap install incus\n        sudo incus admin init --auto\n    - name: Run Incus Tests\n      run: sudo make test-incus\n</code></pre> <p>Note: Many CI runners don't support nested virtualization, so Incus VM tests may need to run on self-hosted runners with KVM support.</p>"},{"location":"tools/nbc/INCUS-TESTS/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tools/nbc/INCUS-TESTS/#custom-test-image","title":"Custom Test Image","text":"<p>Edit <code>test_incus.sh</code> to use your own bootc image:</p> <pre><code>TEST_IMAGE=\"quay.io/your-org/your-bootc-image:latest\"\n</code></pre>"},{"location":"tools/nbc/INCUS-TESTS/#smaller-disk","title":"Smaller Disk","text":"<p>For faster tests with smaller images:</p> <pre><code>DISK_SIZE=\"30GB\"\n</code></pre>"},{"location":"tools/nbc/INCUS-TESTS/#keep-vm-after-tests","title":"Keep VM After Tests","text":"<p>Comment out the cleanup trap:</p> <pre><code># trap cleanup EXIT INT TERM\n</code></pre> <p>Then manually inspect the VM:</p> <pre><code>incus exec nbc-test-&lt;PID&gt; -- bash\n</code></pre>"},{"location":"tools/nbc/INCUS-TESTS/#comparison-with-other-tests","title":"Comparison with Other Tests","text":"Test Type Isolation Bootloader Speed Realism Unit Process No Fast Low Loop Device Process No Medium Medium Incus VM Full VM Yes Slow High <p>Incus tests provide the highest confidence that nbc works in real-world scenarios.</p>"},{"location":"tools/nbc/JSON-OUTPUT/","title":"JSON Output Format for Machine-Readable Output","text":"<p>nbc supports streaming JSON Lines (JSONL) output for machine-readable consumption by installers, update tools, and automation systems. This document describes the output format and how to consume it.</p>"},{"location":"tools/nbc/JSON-OUTPUT/#enabling-json-output","title":"Enabling JSON Output","text":"<p>Add the <code>--json</code> flag to any command:</p> <pre><code>nbc list --json\nnbc install --image myimage:latest --device /dev/sda --json\nnbc update --json\nnbc status --json\nnbc validate --device /dev/sda --json\n</code></pre>"},{"location":"tools/nbc/JSON-OUTPUT/#output-format","title":"Output Format","text":""},{"location":"tools/nbc/JSON-OUTPUT/#simple-commands-list-status-validate","title":"Simple Commands (list, status, validate)","text":"<p>For simple query commands, nbc outputs a single JSON object with the complete result:</p> <pre><code>nbc list --json\n</code></pre> <pre><code>{\n  \"disks\": [\n    {\n      \"device\": \"/dev/sda\",\n      \"size\": 500107862016,\n      \"size_human\": \"465.8 GB\",\n      \"model\": \"Samsung SSD 860\",\n      \"is_removable\": false,\n      \"partitions\": [\n        {\n          \"device\": \"/dev/sda1\",\n          \"size\": 536870912,\n          \"size_human\": \"512.0 MB\",\n          \"mount_point\": \"/boot/efi\",\n          \"filesystem\": \"vfat\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"tools/nbc/JSON-OUTPUT/#streaming-commands-install-update","title":"Streaming Commands (install, update)","text":"<p>For long-running operations, nbc outputs JSON Lines (one JSON object per line) to provide real-time progress updates:</p> <pre><code>nbc install --image myimage:latest --device /dev/sda --json\n</code></pre> <pre><code>{\"type\":\"message\",\"timestamp\":\"2025-12-19T10:30:00Z\",\"message\":\"Checking prerequisites...\"}\n{\"type\":\"message\",\"timestamp\":\"2025-12-19T10:30:01Z\",\"message\":\"Validating disk /dev/sda...\"}\n{\"type\":\"step\",\"timestamp\":\"2025-12-19T10:30:02Z\",\"step\":1,\"total_steps\":6,\"step_name\":\"Creating partitions\"}\n{\"type\":\"message\",\"timestamp\":\"2025-12-19T10:30:03Z\",\"message\":\"Created EFI partition\"}\n{\"type\":\"step\",\"timestamp\":\"2025-12-19T10:30:10Z\",\"step\":2,\"total_steps\":6,\"step_name\":\"Formatting partitions\"}\n{\"type\":\"step\",\"timestamp\":\"2025-12-19T10:30:20Z\",\"step\":3,\"total_steps\":6,\"step_name\":\"Mounting partitions\"}\n{\"type\":\"step\",\"timestamp\":\"2025-12-19T10:30:21Z\",\"step\":4,\"total_steps\":6,\"step_name\":\"Extracting container filesystem\"}\n{\"type\":\"step\",\"timestamp\":\"2025-12-19T10:31:00Z\",\"step\":5,\"total_steps\":6,\"step_name\":\"Configuring system\"}\n{\"type\":\"step\",\"timestamp\":\"2025-12-19T10:31:10Z\",\"step\":6,\"total_steps\":6,\"step_name\":\"Installing bootloader\"}\n{\"type\":\"complete\",\"timestamp\":\"2025-12-19T10:31:20Z\",\"message\":\"Installation complete! You can now boot from this disk.\",\"details\":{\"image\":\"myimage:latest\",\"device\":\"/dev/sda\",\"filesystem\":\"ext4\"}}\n</code></pre>"},{"location":"tools/nbc/JSON-OUTPUT/#event-types","title":"Event Types","text":"<p>Each JSON line contains a <code>type</code> field indicating the event type:</p> Type Description <code>step</code> Start of a numbered step in the operation <code>progress</code> Progress update within a step (with percentage) <code>message</code> Informational message <code>warning</code> Warning that doesn't stop the operation <code>error</code> Error that caused the operation to fail <code>complete</code> Successful completion of the entire operation"},{"location":"tools/nbc/JSON-OUTPUT/#event-schema","title":"Event Schema","text":""},{"location":"tools/nbc/JSON-OUTPUT/#step-event","title":"Step Event","text":"<pre><code>{\n  \"type\": \"step\",\n  \"timestamp\": \"2025-12-19T10:30:02Z\",\n  \"step\": 1,\n  \"total_steps\": 6,\n  \"step_name\": \"Creating partitions\"\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"step\"</code> <code>timestamp</code> string ISO 8601 timestamp (UTC) <code>step</code> integer Current step number (1-based) <code>total_steps</code> integer Total number of steps <code>step_name</code> string Human-readable step description"},{"location":"tools/nbc/JSON-OUTPUT/#progress-event","title":"Progress Event","text":"<pre><code>{\n  \"type\": \"progress\",\n  \"timestamp\": \"2025-12-19T10:30:30Z\",\n  \"percent\": 45,\n  \"message\": \"Extracting layer 3/5\"\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"progress\"</code> <code>timestamp</code> string ISO 8601 timestamp (UTC) <code>percent</code> integer Progress percentage (0-100) <code>message</code> string Optional progress description"},{"location":"tools/nbc/JSON-OUTPUT/#message-event","title":"Message Event","text":"<pre><code>{\n  \"type\": \"message\",\n  \"timestamp\": \"2025-12-19T10:30:05Z\",\n  \"message\": \"Image reference is valid and accessible\"\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"message\"</code> <code>timestamp</code> string ISO 8601 timestamp (UTC) <code>message</code> string Informational message"},{"location":"tools/nbc/JSON-OUTPUT/#warning-event","title":"Warning Event","text":"<pre><code>{\n  \"type\": \"warning\",\n  \"timestamp\": \"2025-12-19T10:30:15Z\",\n  \"message\": \"Could not get image digest: network timeout\"\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"warning\"</code> <code>timestamp</code> string ISO 8601 timestamp (UTC) <code>message</code> string Warning description"},{"location":"tools/nbc/JSON-OUTPUT/#error-event","title":"Error Event","text":"<pre><code>{\n  \"type\": \"error\",\n  \"timestamp\": \"2025-12-19T10:30:20Z\",\n  \"message\": \"Installation failed\",\n  \"details\": {\n    \"error\": \"failed to create partitions: device is busy\"\n  }\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"error\"</code> <code>timestamp</code> string ISO 8601 timestamp (UTC) <code>message</code> string Error summary <code>details</code> object Additional error details"},{"location":"tools/nbc/JSON-OUTPUT/#complete-event","title":"Complete Event","text":"<pre><code>{\n  \"type\": \"complete\",\n  \"timestamp\": \"2025-12-19T10:31:20Z\",\n  \"message\": \"Installation complete! You can now boot from this disk.\",\n  \"details\": {\n    \"image\": \"myimage:latest\",\n    \"device\": \"/dev/sda\",\n    \"filesystem\": \"ext4\"\n  }\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"complete\"</code> <code>timestamp</code> string ISO 8601 timestamp (UTC) <code>message</code> string Completion message <code>details</code> object Operation-specific result data"},{"location":"tools/nbc/JSON-OUTPUT/#consuming-json-output","title":"Consuming JSON Output","text":""},{"location":"tools/nbc/JSON-OUTPUT/#shell-script-example","title":"Shell Script Example","text":"<pre><code>#!/bin/bash\n\nnbc install --image \"$IMAGE\" --device \"$DEVICE\" --json | while IFS= read -r line; do\n    type=$(echo \"$line\" | jq -r '.type')\n\n    case \"$type\" in\n        step)\n            step=$(echo \"$line\" | jq -r '.step')\n            total=$(echo \"$line\" | jq -r '.total_steps')\n            name=$(echo \"$line\" | jq -r '.step_name')\n            echo \"[$step/$total] $name\"\n            ;;\n        message)\n            echo \"  $(echo \"$line\" | jq -r '.message')\"\n            ;;\n        warning)\n            echo \"WARNING: $(echo \"$line\" | jq -r '.message')\" &gt;&amp;2\n            ;;\n        error)\n            echo \"ERROR: $(echo \"$line\" | jq -r '.message')\" &gt;&amp;2\n            exit 1\n            ;;\n        complete)\n            echo \"SUCCESS: $(echo \"$line\" | jq -r '.message')\"\n            ;;\n    esac\ndone\n</code></pre>"},{"location":"tools/nbc/JSON-OUTPUT/#python-example","title":"Python Example","text":"<pre><code>#!/usr/bin/env python3\nimport subprocess\nimport json\nimport sys\n\ndef run_nbc_install(image: str, device: str):\n    proc = subprocess.Popen(\n        [\"nbc\", \"install\", \"--image\", image, \"--device\", device, \"--json\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True\n    )\n\n    for line in proc.stdout:\n        event = json.loads(line.strip())\n        event_type = event.get(\"type\")\n\n        if event_type == \"step\":\n            step = event[\"step\"]\n            total = event[\"total_steps\"]\n            name = event[\"step_name\"]\n            print(f\"[{step}/{total}] {name}\")\n\n        elif event_type == \"progress\":\n            percent = event.get(\"percent\", 0)\n            message = event.get(\"message\", \"\")\n            print(f\"  {percent}% - {message}\")\n\n        elif event_type == \"message\":\n            print(f\"  {event['message']}\")\n\n        elif event_type == \"warning\":\n            print(f\"WARNING: {event['message']}\", file=sys.stderr)\n\n        elif event_type == \"error\":\n            print(f\"ERROR: {event['message']}\", file=sys.stderr)\n            details = event.get(\"details\", {})\n            if \"error\" in details:\n                print(f\"  Details: {details['error']}\", file=sys.stderr)\n            return False\n\n        elif event_type == \"complete\":\n            print(f\"\\nSUCCESS: {event['message']}\")\n            details = event.get(\"details\", {})\n            return True\n\n    proc.wait()\n    return proc.returncode == 0\n\nif __name__ == \"__main__\":\n    success = run_nbc_install(\"myimage:latest\", \"/dev/sda\")\n    sys.exit(0 if success else 1)\n</code></pre>"},{"location":"tools/nbc/JSON-OUTPUT/#go-example","title":"Go Example","text":"<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"encoding/json\"\n    \"fmt\"\n    \"os/exec\"\n)\n\ntype ProgressEvent struct {\n    Type       string                 `json:\"type\"`\n    Timestamp  string                 `json:\"timestamp\"`\n    Step       int                    `json:\"step,omitempty\"`\n    TotalSteps int                    `json:\"total_steps,omitempty\"`\n    StepName   string                 `json:\"step_name,omitempty\"`\n    Message    string                 `json:\"message,omitempty\"`\n    Percent    int                    `json:\"percent,omitempty\"`\n    Details    map[string]interface{} `json:\"details,omitempty\"`\n}\n\nfunc runNbcInstall(image, device string) error {\n    cmd := exec.Command(\"nbc\", \"install\", \"--image\", image, \"--device\", device, \"--json\")\n    stdout, err := cmd.StdoutPipe()\n    if err != nil {\n        return err\n    }\n\n    if err := cmd.Start(); err != nil {\n        return err\n    }\n\n    scanner := bufio.NewScanner(stdout)\n    for scanner.Scan() {\n        var event ProgressEvent\n        if err := json.Unmarshal(scanner.Bytes(), &amp;event); err != nil {\n            continue\n        }\n\n        switch event.Type {\n        case \"step\":\n            fmt.Printf(\"[%d/%d] %s\\n\", event.Step, event.TotalSteps, event.StepName)\n        case \"message\":\n            fmt.Printf(\"  %s\\n\", event.Message)\n        case \"warning\":\n            fmt.Printf(\"WARNING: %s\\n\", event.Message)\n        case \"error\":\n            return fmt.Errorf(\"%s\", event.Message)\n        case \"complete\":\n            fmt.Printf(\"\\nSUCCESS: %s\\n\", event.Message)\n        }\n    }\n\n    return cmd.Wait()\n}\n</code></pre>"},{"location":"tools/nbc/JSON-OUTPUT/#command-specific-output","title":"Command-Specific Output","text":""},{"location":"tools/nbc/JSON-OUTPUT/#nbc-update-check-json","title":"<code>nbc update --check --json</code>","text":"<p>The <code>--check</code> flag outputs a single JSON object (not streaming):</p> <pre><code>{\n  \"update_needed\": true,\n  \"image\": \"myimage:latest\",\n  \"device\": \"/dev/sda\",\n  \"current_digest\": \"sha256:abc123...\",\n  \"new_digest\": \"sha256:def456...\",\n  \"message\": \"Update available\"\n}\n</code></pre>"},{"location":"tools/nbc/JSON-OUTPUT/#nbc-status-json","title":"<code>nbc status --json</code>","text":"<pre><code>{\n  \"image\": \"myimage:latest\",\n  \"digest\": \"sha256:abc123...\",\n  \"device\": \"/dev/sda\",\n  \"active_root\": \"/dev/sda3\",\n  \"active_slot\": \"A (root1)\",\n  \"bootloader_type\": \"grub2\",\n  \"filesystem_type\": \"ext4\",\n  \"install_date\": \"2025-12-19T10:00:00Z\",\n  \"kernel_args\": [\"console=ttyS0\"],\n  \"update_check\": {\n    \"available\": false,\n    \"remote_digest\": \"sha256:abc123...\",\n    \"current_digest\": \"sha256:abc123...\"\n  }\n}\n</code></pre>"},{"location":"tools/nbc/JSON-OUTPUT/#nbc-validate-json","title":"<code>nbc validate --json</code>","text":"<pre><code>{\n  \"device\": \"/dev/sda\",\n  \"valid\": true,\n  \"message\": \"Device is valid for bootc installation\"\n}\n</code></pre> <p>Or on error:</p> <pre><code>{\n  \"device\": \"/dev/sda\",\n  \"valid\": false,\n  \"error\": \"device size 8GB is less than minimum required 10GB\"\n}\n</code></pre>"},{"location":"tools/nbc/JSON-OUTPUT/#important-notes","title":"Important Notes","text":"<ol> <li> <p>Interactive Prompts: When using <code>--json</code>, interactive confirmation prompts are skipped. Use this flag only in automated environments where you've validated the operation is safe.</p> </li> <li> <p>Exit Codes: nbc still uses standard exit codes (0 for success, non-zero for errors) even with <code>--json</code> output. Check both the exit code and the final event type.</p> </li> <li> <p>Line-by-Line Parsing: Each line is a complete, valid JSON object. Parse line-by-line, not as a single JSON array.</p> </li> <li> <p>Timestamps: All timestamps are in UTC and formatted as ISO 8601 (RFC 3339).</p> </li> <li> <p>Buffering: Output is line-buffered. Each event is flushed immediately for real-time progress monitoring.</p> </li> <li> <p>Stderr: Errors are still written to the JSON output on stdout. Stderr may contain additional debug information when using <code>--verbose</code>.</p> </li> </ol>"},{"location":"tools/nbc/LINT/","title":"Container Image Linting","text":"<p>The <code>nbc lint</code> command checks container images for common issues that cause problems when installed with nbc. This document describes each lint check, why it matters, and how issues are remediated.</p>"},{"location":"tools/nbc/LINT/#usage","title":"Usage","text":"<pre><code># Lint a remote container image\nnbc lint ghcr.io/myorg/myimage:latest\n\n# Lint with JSON output (for CI/CD)\nnbc lint --json docker.io/library/fedora:latest\n\n# Lint the current filesystem (inside a container build)\nnbc lint --local\n\n# Lint and automatically fix issues (inside a container only)\nnbc lint --local --fix\n</code></pre>"},{"location":"tools/nbc/LINT/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 No errors found (warnings are allowed) 1 One or more errors found"},{"location":"tools/nbc/LINT/#lint-checks","title":"Lint Checks","text":""},{"location":"tools/nbc/LINT/#ssh-host-keys","title":"ssh-host-keys","text":"<p>Severity: Error</p> <p>What it checks: Detects SSH host keys (<code>/etc/ssh/ssh_host_*_key</code> and <code>/etc/ssh/ssh_host_*_key.pub</code>) baked into the container image.</p> <p>Why it matters: SSH host keys are used to uniquely identify a machine. If they're baked into a container image:</p> <ul> <li>Every system installed from that image will have the same host keys</li> <li>This is a security vulnerability (enables MITM attacks)</li> <li>SSH clients will show warnings when connecting to different hosts with the same keys</li> </ul> <p>Auto-fix behavior: Removes all SSH host key files. They will be regenerated automatically at first boot by <code>sshd-keygen.service</code> or equivalent.</p> <p>Manual fix:</p> <pre><code>RUN rm -f /etc/ssh/ssh_host_*\n</code></pre>"},{"location":"tools/nbc/LINT/#machine-id","title":"machine-id","text":"<p>Severity: Error</p> <p>What it checks: Detects a non-empty <code>/etc/machine-id</code> that contains a value other than \"uninitialized\".</p> <p>Why it matters: The machine-id is a unique identifier for each system. If baked into an image:</p> <ul> <li>Every system will have the same machine-id</li> <li>This breaks systemd's assumptions about unique system identity</li> <li>Can cause issues with logging, D-Bus, and other systemd services</li> <li>May cause problems with software licensing and telemetry</li> </ul> <p>Auto-fix behavior: Truncates <code>/etc/machine-id</code> to zero length. systemd will generate a new unique ID at first boot.</p> <p>Manual fix:</p> <pre><code>RUN truncate -s 0 /etc/machine-id\n# Or alternatively:\nRUN echo \"uninitialized\" &gt; /etc/machine-id\n</code></pre>"},{"location":"tools/nbc/LINT/#random-seed","title":"random-seed","text":"<p>Severity: Warning</p> <p>What it checks: Detects random seed files at:</p> <ul> <li><code>/var/lib/systemd/random-seed</code></li> <li><code>/var/lib/random-seed</code> (legacy location)</li> </ul> <p>Why it matters: Random seed files contain entropy used to initialize the random number generator. If shared across systems:</p> <ul> <li>Reduces the entropy available at boot</li> <li>Could potentially weaken cryptographic operations</li> <li>Not a critical security issue, but not ideal</li> </ul> <p>Auto-fix behavior: Removes the random seed files. They will be regenerated at boot.</p> <p>Manual fix:</p> <pre><code>RUN rm -f /var/lib/systemd/random-seed /var/lib/random-seed\n</code></pre>"},{"location":"tools/nbc/LINT/#safety-checks","title":"Safety Checks","text":""},{"location":"tools/nbc/LINT/#container-environment-detection","title":"Container Environment Detection","text":"<p>When using <code>--fix</code>, the lint command verifies it's running inside a container by checking for:</p> <ul> <li><code>/.dockerenv</code> (Docker)</li> <li><code>/run/.containerenv</code> (Podman)</li> </ul> <p>This prevents accidentally running <code>--fix</code> on a host system, which could remove important files.</p>"},{"location":"tools/nbc/LINT/#adding-new-lint-checks","title":"Adding New Lint Checks","text":"<p>When adding a new lint check to <code>pkg/lint.go</code>:</p> <ol> <li>Create the check function following the <code>LintCheck</code> signature</li> <li>Register it in <code>RegisterDefaultChecks()</code></li> <li>Update this document with:</li> <li>Check name and severity</li> <li>What it checks</li> <li>Why it matters</li> <li>Auto-fix behavior</li> <li>Manual fix instructions</li> </ol> <p>See the documentation in <code>pkg/lint.go</code> for detailed implementation instructions.</p>"},{"location":"tools/nbc/LINT/#cicd-integration","title":"CI/CD Integration","text":"<p>Use JSON output for machine-readable results:</p> <pre><code>nbc lint --json ghcr.io/myorg/myimage:latest\n</code></pre> <p>Example JSON output:</p> <pre><code>{\n  \"image\": \"ghcr.io/myorg/myimage:latest\",\n  \"success\": true,\n  \"issues\": [\n    {\n      \"check\": \"ssh-host-keys\",\n      \"severity\": \"error\",\n      \"message\": \"SSH host key found in image\",\n      \"path\": \"/etc/ssh/ssh_host_rsa_key\"\n    }\n  ],\n  \"error_count\": 1,\n  \"warning_count\": 0\n}\n</code></pre>"},{"location":"tools/nbc/LINT/#dockerfile-integration","title":"Dockerfile Integration","text":"<p>Add lint as the final step in your Dockerfile:</p> <pre><code># Install nbc (adjust for your base image)\nCOPY --from=ghcr.io/frostyard/nbc:latest /nbc /usr/local/bin/nbc\n\n# Lint and fix issues\nRUN nbc lint --local --fix\n</code></pre> <p>Or just lint without fixing (fail the build if issues exist):</p> <pre><code>RUN nbc lint --local\n</code></pre>"},{"location":"tools/nbc/SECURE-BOOT/","title":"Secure Boot Support in nbc","text":"<p>This document describes how nbc handles Secure Boot for both GRUB2 and systemd-boot bootloaders.</p>"},{"location":"tools/nbc/SECURE-BOOT/#overview","title":"Overview","text":"<p>Secure Boot is a UEFI feature that ensures only signed bootloaders can execute. The trust chain works as follows:</p> <ol> <li>UEFI Firmware trusts Microsoft's UEFI CA</li> <li>Shim is signed by Microsoft, so firmware trusts it</li> <li>Shim contains the distro's key (e.g., Debian, Fedora) and trusts binaries signed by that key</li> <li>Bootloader (GRUB or systemd-boot) is signed by the distro, so shim trusts it</li> <li>Kernel is either signed or loaded via MOK (Machine Owner Key)</li> </ol>"},{"location":"tools/nbc/SECURE-BOOT/#the-shim-bootloader","title":"The Shim Bootloader","text":"<p>Shim is the critical component for Secure Boot. Key facts:</p> <ul> <li>Signed by Microsoft: UEFI firmware trusts it</li> <li>Contains distro key: Can verify distro-signed binaries</li> <li>Hardcoded to load <code>grubx64.efi</code>: Looks for this file in the same directory</li> <li>Only verifies signature: Doesn't care what grubx64.efi actually is</li> </ul> <p>This last point is crucial: shim will happily load a signed systemd-boot binary as long as it's named <code>grubx64.efi</code> and signed by the distro key.</p>"},{"location":"tools/nbc/SECURE-BOOT/#efi-directory-layout","title":"EFI Directory Layout","text":""},{"location":"tools/nbc/SECURE-BOOT/#for-systemd-boot-debianubuntu","title":"For systemd-boot (Debian/Ubuntu)","text":"<pre><code>/boot/EFI/\n\u251c\u2500\u2500 BOOT/\n\u2502   \u251c\u2500\u2500 BOOTX64.EFI      \u2190 shimx64.efi.signed (957KB)\n\u2502   \u251c\u2500\u2500 grubx64.efi      \u2190 systemd-bootx64.efi.signed (125KB) - NOT GRUB!\n\u2502   \u2514\u2500\u2500 mmx64.efi        \u2190 mmx64.efi.signed (850KB, optional)\n\u2514\u2500\u2500 systemd/\n    \u2514\u2500\u2500 systemd-bootx64.efi  \u2190 copy for bootctl discoverability\n</code></pre>"},{"location":"tools/nbc/SECURE-BOOT/#for-grub2-fedorarhel","title":"For GRUB2 (Fedora/RHEL)","text":"<pre><code>/boot/EFI/\n\u251c\u2500\u2500 BOOT/\n\u2502   \u251c\u2500\u2500 BOOTX64.EFI      \u2190 shimx64.efi\n\u2502   \u251c\u2500\u2500 grubx64.efi      \u2190 signed grubx64.efi from container\n\u2502   \u2514\u2500\u2500 mmx64.efi        \u2190 MOK manager (optional)\n\u2514\u2500\u2500 fedora/              \u2190 or centos, redhat\n    \u2514\u2500\u2500 grub.cfg         \u2190 GRUB configuration\n</code></pre>"},{"location":"tools/nbc/SECURE-BOOT/#source-locations-for-signed-binaries","title":"Source Locations for Signed Binaries","text":""},{"location":"tools/nbc/SECURE-BOOT/#debianubuntu","title":"Debian/Ubuntu","text":"Binary Location in Container Shim <code>/usr/lib/shim/shimx64.efi.signed</code> MOK Manager <code>/usr/lib/shim/mmx64.efi.signed</code> systemd-boot <code>/usr/lib/systemd/boot/efi/systemd-bootx64.efi.signed</code> Fallback <code>/usr/lib/shim/fbx64.efi.signed</code> (DO NOT USE)"},{"location":"tools/nbc/SECURE-BOOT/#fedorarhelcentos","title":"Fedora/RHEL/CentOS","text":"Binary Location in Container Shim <code>/boot/efi/EFI/{distro}/shimx64.efi</code> GRUB <code>/boot/efi/EFI/{distro}/grubx64.efi</code> MOK Manager <code>/boot/efi/EFI/{distro}/mmx64.efi</code>"},{"location":"tools/nbc/SECURE-BOOT/#what-not-to-do","title":"What NOT to Do","text":""},{"location":"tools/nbc/SECURE-BOOT/#do-not-install-fbx64efi","title":"\u274c Do NOT install fbx64.efi","text":"<p>The fallback bootloader (<code>fbx64.efi</code>) causes a \"Restore Boot Option\" blue screen because:</p> <ol> <li>fbx64.efi looks for <code>EFI/&lt;distro&gt;/BOOTX64.CSV</code></li> <li>Our setup uses <code>EFI/BOOT/</code> (removable media path)</li> <li>When CSV is not found, fbx64.efi shows the blue screen</li> </ol> <p>We use <code>efibootmgr</code> to register boot entries instead.</p>"},{"location":"tools/nbc/SECURE-BOOT/#do-not-use-unsigned-binaries","title":"\u274c Do NOT use unsigned binaries","text":"<ul> <li><code>grub-install</code> produces unsigned GRUB EFI binaries</li> <li>These will be rejected by Secure Boot</li> <li>Always use the signed binaries from the container image</li> </ul>"},{"location":"tools/nbc/SECURE-BOOT/#do-not-use-signed-systemd-boot-directly-as-bootx64efi","title":"\u274c Do NOT use signed systemd-boot directly as BOOTX64.EFI","text":"<ul> <li>Distro signing keys are not in UEFI firmware's trust store</li> <li>Only Microsoft-signed binaries (like shim) are trusted directly</li> <li>Must go through shim chain</li> </ul>"},{"location":"tools/nbc/SECURE-BOOT/#do-not-assume-efi-directory-case","title":"\u274c Do NOT assume EFI directory case","text":"<ul> <li>Container extraction may create lowercase <code>efi</code></li> <li>FAT32 is case-insensitive but case-preserving</li> <li>Use two-step rename: <code>efi</code> \u2192 <code>efi_tmp</code> \u2192 <code>EFI</code></li> </ul>"},{"location":"tools/nbc/SECURE-BOOT/#debugging-guide","title":"Debugging Guide","text":""},{"location":"tools/nbc/SECURE-BOOT/#restore-boot-option-blue-screen","title":"\"Restore Boot Option\" Blue Screen","text":"<p>Cause: fbx64.efi is being executed</p> <p>Solution: Remove fbx64.efi from <code>EFI/BOOT/</code></p> <pre><code># From rescue environment\nmount /dev/sda1 /mnt\nrm /mnt/EFI/BOOT/fbx64.efi\numount /mnt\nreboot\n</code></pre>"},{"location":"tools/nbc/SECURE-BOOT/#access-denied-error","title":"\"Access Denied\" Error","text":"<p>Cause: Secure Boot rejected an unsigned or incorrectly-signed binary</p> <p>Solutions:</p> <ol> <li>Ensure shim is used as BOOTX64.EFI (not systemd-boot directly)</li> <li>Verify grubx64.efi is the signed binary from the container</li> <li>Check that shim and bootloader are from the same distro</li> </ol>"},{"location":"tools/nbc/SECURE-BOOT/#system-boots-to-wrong-device","title":"System Boots to Wrong Device","text":"<p>Cause: Boot order not set correctly</p> <p>Solution:</p> <pre><code># Check current order\nefibootmgr -v\n\n# Set your OS first (replace 0008 with your boot entry)\nefibootmgr -o 0008,0002,0003\n</code></pre>"},{"location":"tools/nbc/SECURE-BOOT/#bootctl-shows-secure-boot-disabled","title":"bootctl Shows \"Secure Boot: disabled\"","text":"<p>Possible causes:</p> <ol> <li>Secure Boot not enabled in firmware</li> <li>Booted directly, not through shim</li> </ol> <p>Verification:</p> <pre><code>mokutil --sb-state  # Should say \"SecureBoot enabled\"\n</code></pre>"},{"location":"tools/nbc/SECURE-BOOT/#investigation-history-december-2025","title":"Investigation History (December 2025)","text":"<p>This section documents the debugging process that led to the current implementation.</p>"},{"location":"tools/nbc/SECURE-BOOT/#initial-problem","title":"Initial Problem","text":"<p>After installing a Debian system with systemd-boot using nbc, Secure Boot failed with various symptoms including \"Restore Boot Option\" blue screen.</p>"},{"location":"tools/nbc/SECURE-BOOT/#failed-attempt-1-using-unsigned-bootloaders","title":"Failed Attempt 1: Using unsigned bootloaders","text":"<ul> <li>Tried using <code>grub-install</code> output directly</li> <li>Result: Secure Boot rejected the unsigned binary</li> </ul>"},{"location":"tools/nbc/SECURE-BOOT/#failed-attempt-2-signed-systemd-boot-as-bootx64efi","title":"Failed Attempt 2: Signed systemd-boot as BOOTX64.EFI","text":"<ul> <li>Assumption: Distro-signed binaries are in Microsoft's trust chain</li> <li>Reality: They're not - only shim is Microsoft-signed</li> <li>Result: \"Access Denied\"</li> </ul>"},{"location":"tools/nbc/SECURE-BOOT/#failed-attempt-3-shim-systemd-boot-fbx64efi","title":"Failed Attempt 3: Shim + systemd-boot + fbx64.efi","text":"<ul> <li>Included fbx64.efi thinking it was needed for boot recovery</li> <li>Result: \"Restore Boot Option\" blue screen</li> <li>Root cause: fbx64.efi couldn't find BOOTX64.CSV</li> </ul>"},{"location":"tools/nbc/SECURE-BOOT/#failed-attempt-4-incorrect-assumption-about-systemd-boot-path","title":"Failed Attempt 4: Incorrect assumption about systemd-boot path","text":"<ul> <li>Assumed systemd-boot couldn't work as grubx64.efi because it \"needs to know its path\"</li> <li>This was wrong - systemd-boot finds loader.conf relative to ESP root</li> <li>Wasted time trying alternative approaches</li> </ul>"},{"location":"tools/nbc/SECURE-BOOT/#working-solution","title":"Working Solution","text":"<ol> <li>Shim as BOOTX64.EFI - Microsoft-signed, trusted by firmware</li> <li>Signed systemd-boot as grubx64.efi - Distro-signed, trusted by shim</li> <li>MOK manager - For key enrollment if needed</li> <li>NO fbx64.efi - Causes blue screen</li> </ol>"},{"location":"tools/nbc/SECURE-BOOT/#key-insight","title":"Key Insight","text":"<p>Shim doesn't care what <code>grubx64.efi</code> actually is. It only:</p> <ol> <li>Looks for a file named <code>grubx64.efi</code> in the same directory</li> <li>Verifies the signature against the embedded distro key</li> <li>Loads and executes it if signature is valid</li> </ol> <p>This means systemd-boot works perfectly as <code>grubx64.efi</code> because:</p> <ul> <li>It's signed by Debian's key</li> <li>Shim trusts Debian's key</li> <li>systemd-boot doesn't care what filename it's loaded as</li> </ul>"},{"location":"tools/nbc/SECURE-BOOT/#testing-secure-boot","title":"Testing Secure Boot","text":""},{"location":"tools/nbc/SECURE-BOOT/#create-a-secure-boot-vm-with-incus","title":"Create a Secure Boot VM with Incus","text":"<pre><code># Create VM with Secure Boot enabled\nincus launch images:debian/trixie myvm --vm \\\n  -c security.secureboot=true\n\n# Attach install ISO\nincus config device add myvm iso disk \\\n  source=/path/to/installer.iso boot.priority=10\n\n# Start and connect\nincus start myvm\nincus console myvm\n</code></pre>"},{"location":"tools/nbc/SECURE-BOOT/#verify-secure-boot-status","title":"Verify Secure Boot Status","text":"<pre><code># Inside the running system\nmokutil --sb-state\n# Should output: SecureBoot enabled\n\nbootctl status\n# Should show: Secure Boot: enabled (user)\n</code></pre>"},{"location":"tools/nbc/SECURE-BOOT/#verify-correct-binaries","title":"Verify Correct Binaries","text":"<pre><code># Check file sizes to identify binaries\nls -la /boot/EFI/BOOT/\n\n# Expected:\n# BOOTX64.EFI ~957KB (shim)\n# grubx64.efi ~125KB (systemd-boot) or ~2MB (GRUB)\n# mmx64.efi   ~850KB (MOK manager)\n</code></pre>"},{"location":"tools/nbc/SECURE-BOOT/#related-files","title":"Related Files","text":"<ul> <li><code>pkg/bootloader.go</code> - Main bootloader installation code</li> <li><code>setupSystemdBootSecureBootChain()</code> - systemd-boot Secure Boot setup</li> <li><code>setupSecureBootChain()</code> - GRUB2 Secure Boot setup</li> <li><code>findShimEFI()</code>, <code>findSignedSystemdBootEFI()</code>, etc. - Binary locators</li> </ul>"},{"location":"tools/nbc/TESTING/","title":"Testing Guide","text":"<p>This document describes how to test nbc using disk image files and loop devices.</p>"},{"location":"tools/nbc/TESTING/#test-types","title":"Test Types","text":""},{"location":"tools/nbc/TESTING/#unit-tests","title":"Unit Tests","text":"<p>Unit tests that don't require root or physical devices:</p> <pre><code>make test-unit\n</code></pre> <p>These tests cover:</p> <ul> <li><code>TestFormatSize</code> - Size formatting utilities</li> <li><code>TestGetBootDeviceFromPartition</code> - Device name parsing</li> <li><code>TestGetDiskByPath</code> - Path resolution (skips non-existent devices)</li> </ul>"},{"location":"tools/nbc/TESTING/#integration-tests","title":"Integration Tests","text":"<p>Integration tests that use disk images and require root privileges:</p> <pre><code>sudo make test-integration\n</code></pre> <p>These tests cover:</p> <ul> <li><code>TestCreatePartitions</code> - GPT partition table creation</li> <li><code>TestFormatPartitions</code> - Filesystem formatting</li> <li><code>TestMountPartitions</code> - Partition mounting/unmounting</li> <li><code>TestDetectExistingPartitionScheme</code> - Partition scheme detection</li> </ul>"},{"location":"tools/nbc/TESTING/#test-infrastructure","title":"Test Infrastructure","text":""},{"location":"tools/nbc/TESTING/#disk-image-creation","title":"Disk Image Creation","text":"<p>The test suite uses loop devices to simulate physical disks without requiring actual hardware. The <code>testutil</code> package provides utilities for creating and managing test disk images:</p> <pre><code>// Create a 50GB test disk image attached to a loop device\ndisk, err := testutil.CreateTestDisk(t, 50)\nif err != nil {\n    t.Fatalf(\"Failed to create test disk: %v\", err)\n}\n\n// Use the disk in tests\ndevice := disk.GetDevice() // e.g., /dev/loop0\n\n// Cleanup is automatic via t.Cleanup()\n</code></pre>"},{"location":"tools/nbc/TESTING/#how-it-works","title":"How It Works","text":"<ol> <li>Sparse Files: Creates sparse disk image files (don't use actual disk space)</li> <li>Loop Devices: Attaches images to loop devices (e.g., <code>/dev/loop0</code>)</li> <li>Automatic Cleanup: Test framework automatically detaches loop devices and removes image files</li> <li>Root Required: Loop device operations require root privileges</li> </ol>"},{"location":"tools/nbc/TESTING/#test-utilities","title":"Test Utilities","text":"<p>The <code>pkg/testutil</code> package provides:</p> <ul> <li><code>CreateTestDisk(t, sizeGB)</code> - Create disk image and attach to loop device</li> <li><code>RequireRoot(t)</code> - Skip test if not running as root</li> <li><code>RequireTools(t, tools...)</code> - Skip test if required tools are missing</li> <li><code>CreateMockContainer(t, imageName)</code> - Create minimal test container image</li> <li><code>WaitForDevice(device)</code> - Wait for device to be ready after partitioning</li> <li><code>CleanupMounts(t, mountPoint)</code> - Force unmount all mounts under a path</li> </ul>"},{"location":"tools/nbc/TESTING/#running-tests","title":"Running Tests","text":""},{"location":"tools/nbc/TESTING/#prerequisites","title":"Prerequisites","text":"<pre><code># Required tools\nsudo apt install gdisk dosfstools e2fsprogs podman rsync\n\n# Or on Fedora/RHEL\nsudo dnf install gdisk dosfstools e2fsprogs podman rsync\n</code></pre>"},{"location":"tools/nbc/TESTING/#run-all-tests","title":"Run All Tests","text":"<pre><code># Run unit tests (no root needed)\nmake test-unit\n\n# Run integration tests (requires root)\nsudo make test-integration\n\n# Or use the test script\nsudo ./test_integration.sh\n</code></pre>"},{"location":"tools/nbc/TESTING/#run-specific-tests","title":"Run Specific Tests","text":"<pre><code># Run specific unit test\ngo test -v ./pkg/... -run TestFormatSize\n\n# Run specific integration test (requires root)\nsudo go test -v ./pkg/... -run TestCreatePartitions\n\n# Run installation tests (requires root)\nsudo make test-install\n# Or directly:\nsudo go test -v ./pkg/... -run TestBootcInstaller -timeout 20m\n\n# Run update tests (requires root)\nsudo make test-update\n# Or directly:\nsudo go test -v ./pkg/... -run TestSystemUpdater -timeout 20m\n</code></pre>"},{"location":"tools/nbc/TESTING/#test-coverage","title":"Test Coverage","text":""},{"location":"tools/nbc/TESTING/#unit-tests-no-root-required","title":"Unit Tests (No Root Required)","text":"<ul> <li>Device name parsing (<code>TestGetBootDeviceFromPartition</code>)</li> <li>Size formatting (<code>TestFormatSize</code>)</li> <li>Path resolution (<code>TestGetDiskByPath</code>)</li> </ul>"},{"location":"tools/nbc/TESTING/#integration-tests-root-required","title":"Integration Tests (Root Required)","text":"<ul> <li>Partition creation (<code>TestCreatePartitions</code>)</li> <li>Partition formatting (<code>TestFormatPartitions</code>)</li> <li>Partition mounting (<code>TestMountPartitions</code>)</li> <li>Partition scheme detection (<code>TestDetectExistingPartitionScheme</code>)</li> </ul>"},{"location":"tools/nbc/TESTING/#installation-tests-root-required","title":"Installation Tests (Root Required)","text":"<ul> <li>Full system installation (<code>TestBootcInstaller_Install</code>)</li> <li>Dry-run mode (<code>TestBootcInstaller_DryRun</code>)</li> <li>Kernel arguments persistence (<code>TestBootcInstaller_WithKernelArgs</code>)</li> </ul>"},{"location":"tools/nbc/TESTING/#update-tests-root-required","title":"Update Tests (Root Required)","text":"<ul> <li>System updates (<code>TestSystemUpdater_Update</code>)</li> <li>/etc configuration persistence (<code>TestSystemUpdater_EtcPersistence</code>)</li> </ul>"},{"location":"tools/nbc/TESTING/#writing-tests","title":"Writing Tests","text":""},{"location":"tools/nbc/TESTING/#example-unit-test","title":"Example Unit Test","text":"<pre><code>func TestMyFunction(t *testing.T) {\n    result := MyFunction(\"input\")\n    if result != \"expected\" {\n        t.Errorf(\"got %s, want %s\", result, \"expected\")\n    }\n}\n</code></pre>"},{"location":"tools/nbc/TESTING/#example-integration-test","title":"Example Integration Test","text":"<pre><code>func TestMyDiskOperation(t *testing.T) {\n    // Check prerequisites\n    testutil.RequireRoot(t)\n    testutil.RequireTools(t, \"sgdisk\", \"mkfs.ext4\")\n\n    // Create test disk\n    disk, err := testutil.CreateTestDisk(t, 10) // 10GB\n    if err != nil {\n        t.Fatalf(\"Failed to create test disk: %v\", err)\n    }\n\n    // Perform operations\n    device := disk.GetDevice()\n    // ... your test code here ...\n\n    // Cleanup is automatic\n}\n</code></pre>"},{"location":"tools/nbc/TESTING/#example-installation-test","title":"Example Installation Test","text":"<pre><code>func TestMyInstallation(t *testing.T) {\n    testutil.RequireRoot(t)\n    testutil.RequireTools(t, \"losetup\", \"sgdisk\", \"mkfs.vfat\", \"mkfs.ext4\", \"podman\")\n\n    // Create test disk\n    disk, err := testutil.CreateTestDisk(t, 50)\n    if err != nil {\n        t.Fatalf(\"Failed to create test disk: %v\", err)\n    }\n\n    // Create mock container\n    imageName := \"localhost/my-test:latest\"\n    if err := testutil.CreateMockContainer(t, imageName); err != nil {\n        t.Fatalf(\"Failed to create container: %v\", err)\n    }\n\n    // Perform installation\n    mountPoint := filepath.Join(t.TempDir(), \"mnt\")\n    installer := NewBootcInstaller(imageName, disk.GetDevice())\n    installer.SetMountPoint(mountPoint)\n    installer.SetVerbose(true)\n\n    defer testutil.CleanupMounts(t, mountPoint)\n\n    if err := installer.Install(); err != nil {\n        t.Fatalf(\"Install failed: %v\", err)\n    }\n\n    // Verify installation\n    // ... verification code ...\n}\n</code></pre>"},{"location":"tools/nbc/TESTING/#test-isolation","title":"Test Isolation","text":"<p>Each test:</p> <ul> <li>Uses isolated temporary directories (<code>t.TempDir()</code>)</li> <li>Gets its own loop device</li> <li>Cleans up automatically on completion or failure</li> <li>Does not interfere with other tests</li> </ul>"},{"location":"tools/nbc/TESTING/#continuous-integration","title":"Continuous Integration","text":"<p>For CI environments:</p> <pre><code># GitHub Actions example\n- name: Run tests\n  run: |\n    # Unit tests (no root)\n    make test-unit\n\n    # Integration tests (with root)\n    sudo make test-integration\n</code></pre>"},{"location":"tools/nbc/TESTING/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tools/nbc/TESTING/#test-requires-root-privileges","title":"\"Test requires root privileges\"","text":"<p>Integration tests need root to create loop devices:</p> <pre><code>sudo make test-integration\n</code></pre>"},{"location":"tools/nbc/TESTING/#required-tool-not-found","title":"\"Required tool not found\"","text":"<p>Install missing tools:</p> <pre><code># Ubuntu/Debian\nsudo apt install gdisk dosfstools e2fsprogs\n\n# Fedora/RHEL\nsudo dnf install gdisk dosfstools e2fsprogs\n</code></pre>"},{"location":"tools/nbc/TESTING/#no-loop-devices-available","title":"\"No loop devices available\"","text":"<p>Load the loop module:</p> <pre><code>sudo modprobe loop\n</code></pre> <p>Or increase max loop devices:</p> <pre><code>sudo modprobe loop max_loop=16\n</code></pre>"},{"location":"tools/nbc/TESTING/#tests-hang-or-leave-loop-devices-attached","title":"Tests hang or leave loop devices attached","text":"<p>The test framework should clean up automatically, but if tests are interrupted:</p> <pre><code># List loop devices\nsudo losetup -a\n\n# Detach specific loop device\nsudo losetup -d /dev/loop0\n\n# Remove test images\nrm -f /tmp/nbc-test-*.img\n</code></pre>"},{"location":"tools/nbc/TESTING/#performance","title":"Performance","text":"<p>Test disk images use sparse files, so:</p> <ul> <li>A 50GB test disk uses ~0 bytes initially</li> <li>Only grows as partitions are written</li> <li>Typical test disk uses &lt; 100MB actual space</li> </ul>"},{"location":"tools/nbc/TESTING/#safety","title":"Safety","text":"<p>Tests are designed to be safe:</p> <ul> <li>Only operate on loop devices (never real disks)</li> <li>Automatically clean up on completion</li> <li>Use temporary directories</li> <li>No system modification outside test scope</li> </ul> <p>Tests cannot accidentally wipe your real disks because they:</p> <ol> <li>Only work with loop devices from test images</li> <li>Don't have access to actual <code>/dev/sd*</code> or <code>/dev/nvme*</code> devices during tests</li> <li>Clean up completely on exit</li> </ol>"},{"location":"tools/nbc/TESTING/#continuous-integration_1","title":"Continuous Integration","text":"<p>The project uses GitHub Actions for automated testing on every push and pull request.</p>"},{"location":"tools/nbc/TESTING/#ci-workflow","title":"CI Workflow","text":"<p>The <code>.github/workflows/test.yml</code> workflow runs:</p> Job Description Runs on Lint golangci-lint for code quality ubuntu-latest Unit Tests All unit tests with coverage ubuntu-latest Build Cross-compilation for linux/amd64 and linux/arm64 ubuntu-latest Integration Tests Info only (requires root/loop devices) -"},{"location":"tools/nbc/TESTING/#coverage-reporting","title":"Coverage Reporting","text":"<p>Unit tests generate coverage data and upload to Codecov (when configured):</p> <pre><code># Generate coverage locally\nmake test-coverage\n\n# View coverage report\ngo tool cover -html=coverage.out\n</code></pre>"},{"location":"tools/nbc/TESTING/#what-ci-cannot-test","title":"What CI Cannot Test","text":"<p>Due to GitHub Actions limitations, these tests require manual execution:</p> <ul> <li>Integration tests (<code>sudo make test-integration</code>) - Require root and loop devices</li> <li>Incus E2E tests (<code>./test_incus.sh</code>) - Require VM creation capability</li> <li>Encryption tests (<code>./test_incus_encryption.sh</code>) - Require LUKS and TPM emulation</li> </ul>"},{"location":"tools/nbc/TESTING/#running-ci-locally","title":"Running CI Locally","text":"<p>You can simulate the CI workflow locally using act:</p> <pre><code># Install act (macOS)\nbrew install act\n\n# Run all CI jobs\nact\n\n# Run specific job\nact -j unit-test\n</code></pre>"},{"location":"tools/nbc/verify_mount_extra_format/","title":"systemd.mount-extra Format Verification","text":""},{"location":"tools/nbc/verify_mount_extra_format/#analysis-summary","title":"Analysis Summary","text":"<p>Based on systemd source code analysis, the current code is INCORRECT.</p>"},{"location":"tools/nbc/verify_mount_extra_format/#evidence-from-systemd-source","title":"Evidence from systemd Source","text":""},{"location":"tools/nbc/verify_mount_extra_format/#1-fstab-generatorc-mount_array_add-function","title":"1. fstab-generator.c (mount_array_add function)","text":"<pre><code>static int mount_array_add(bool for_initrd, const char *str) {\n        _cleanup_free_ char *what = NULL, *where = NULL, *fstype = NULL, *options = NULL;\n        int r;\n\n        r = extract_many_words(&amp;str, \":\", EXTRACT_CUNESCAPE | EXTRACT_DONT_COALESCE_SEPARATORS,\n                               &amp;what, &amp;where, &amp;fstype, &amp;options);\n        if (r &lt; 0)\n                return r;\n        if (r &lt; 2)\n                return -EINVAL;\n        if (!isempty(str))\n                return -EINVAL;\n\n        return mount_array_add_internal(for_initrd, TAKE_PTR(what), TAKE_PTR(where), fstype, TAKE_PTR(options));\n}\n</code></pre> <p>Parse order: <code>what:where:fstype:options</code></p>"},{"location":"tools/nbc/verify_mount_extra_format/#2-vmspawnc-usage-example","title":"2. vmspawn.c Usage Example","text":"<pre><code>if (strv_extendf(&amp;arg_kernel_cmdline_extra, \"systemd.mount-extra=\\\"%s:%s:virtiofs:%s\\\"\",\n                 id, clean_target, mount-&gt;read_only ? \"ro\" : \"rw\") &lt; 0)\n</code></pre> <p>Format: <code>&lt;id&gt;:&lt;clean_target&gt;:virtiofs:&lt;mount_options&gt;</code></p> <ul> <li><code>id</code> = device/source identifier</li> <li><code>clean_target</code> = mount point destination</li> <li><code>virtiofs</code> = filesystem type</li> <li>mount options</li> </ul>"},{"location":"tools/nbc/verify_mount_extra_format/#3-standard-mount8-terminology","title":"3. Standard mount(8) Terminology","text":"<p>From mount(8) manpage and fstab(5):</p> <ul> <li>what = device/source (the thing to mount FROM)</li> <li>where = mount point (the place to mount TO)</li> </ul> <p>Example: <code>mount /dev/sda1 /mnt</code> \u2192 mount WHAT (/dev/sda1) WHERE (/mnt)</p>"},{"location":"tools/nbc/verify_mount_extra_format/#current-code-wrong","title":"Current Code (WRONG)","text":""},{"location":"tools/nbc/verify_mount_extra_format/#bootloadergo-line-251-and-362","title":"bootloader.go line 251 and 362:","text":"<pre><code>\"systemd.mount-extra=/var:UUID=\" + varUUID + \":ext4:defaults\"\n</code></pre> <p>This is parsed as:</p> <ul> <li>what = <code>/var</code> (mount point - WRONG!)</li> <li>where = <code>UUID=...</code> (device - WRONG!)</li> <li>fstype = <code>ext4</code></li> <li>options = <code>defaults</code></li> </ul>"},{"location":"tools/nbc/verify_mount_extra_format/#correct-format","title":"Correct Format","text":"<p>Should be:</p> <pre><code>\"systemd.mount-extra=UUID=\" + varUUID + \":/var:ext4:defaults\"\n</code></pre> <p>This would be parsed as:</p> <ul> <li>what = <code>UUID=...</code> (device - CORRECT!)</li> <li>where = <code>/var</code> (mount point - CORRECT!)</li> <li>fstype = <code>ext4</code></li> <li>options = <code>defaults</code></li> </ul>"},{"location":"tools/nbc/verify_mount_extra_format/#impact","title":"Impact","text":"<p>This bug would cause systemd to:</p> <ol> <li>Try to mount the mount point <code>/var</code> as a device</li> <li>Try to mount TO the device UUID</li> <li>Result in mount failure during boot</li> </ol> <p>The system may fail to boot or /var may not be mounted, leading to various runtime issues.</p>"},{"location":"tools/nbc/verify_mount_extra_format/#files-requiring-fix","title":"Files Requiring Fix","text":"<ol> <li><code>/home/bjk/projects/frostyard/nbc/pkg/bootloader.go</code> line 251 (generateGRUBConfig)</li> <li><code>/home/bjk/projects/frostyard/nbc/pkg/bootloader.go</code> line 355 (generateSystemdBootConfig)</li> </ol> <p>Both occurrences need the format corrected to:</p> <pre><code>\"systemd.mount-extra=UUID=\" + varUUID + \":/var:ext4:defaults\"\n</code></pre>"},{"location":"tools/nbc/cli/nbc/","title":"CLI Reference","text":""},{"location":"tools/nbc/cli/nbc/#nbc","title":"nbc","text":"<p>A bootc container installer for physical disks</p>"},{"location":"tools/nbc/cli/nbc/#synopsis","title":"Synopsis","text":"<p>nbc is a tool for installing bootc compatible containers to physical disks. It automates the process of preparing disks and deploying bootable container images.</p>"},{"location":"tools/nbc/cli/nbc/#options","title":"Options","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n  -h, --help      help for nbc\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc cache  - Manage cached container images</li> <li>nbc completion    - Generate the autocompletion script for the specified shell</li> <li>nbc download    - Download a container image to local cache</li> <li>nbc install  - Install a bootc container to a physical disk</li> <li>nbc interactive-install  - Interactively install a bootc container to a physical disk</li> <li>nbc lint    - Check a container image for common issues</li> <li>nbc list    - List available disks</li> <li>nbc status    - Show current system status</li> <li>nbc update    - Update system to a new container image using A/B partitions</li> <li>nbc validate    - Validate a disk for bootc installation</li> </ul>"},{"location":"tools/nbc/cli/nbc_cache/","title":"Nbc cache","text":""},{"location":"tools/nbc/cli/nbc_cache/#nbc-cache","title":"nbc cache","text":"<p>Manage cached container images</p>"},{"location":"tools/nbc/cli/nbc_cache/#synopsis","title":"Synopsis","text":"<p>Manage cached container images for offline installation and staged updates.</p> <p>Subcommands:   list    - List cached images   remove  - Remove a cached image by digest   clear   - Clear all cached images</p> <p>Examples:   nbc cache list --install-images   nbc cache list --update-images   nbc cache remove sha256-abc123...   nbc cache clear --install   nbc cache clear --update</p>"},{"location":"tools/nbc/cli/nbc_cache/#options","title":"Options","text":"<pre><code>  -h, --help   help for cache\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> <li>nbc cache clear  - Clear all cached images</li> <li>nbc cache list    - List cached container images</li> <li>nbc cache remove    - Remove a cached image by digest</li> </ul>"},{"location":"tools/nbc/cli/nbc_cache_clear/","title":"Nbc cache clear","text":""},{"location":"tools/nbc/cli/nbc_cache_clear/#nbc-cache-clear","title":"nbc cache clear","text":"<p>Clear all cached images</p>"},{"location":"tools/nbc/cli/nbc_cache_clear/#synopsis","title":"Synopsis","text":"<p>Clear all cached images from a cache directory.</p> <p>Use --install to clear staged installation images. Use --update to clear staged update images.</p> <p>Examples:   nbc cache clear --install   nbc cache clear --update</p> <pre><code>nbc cache clear [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache_clear/#options","title":"Options","text":"<pre><code>  -h, --help      help for clear\n      --install   Clear staged installation images\n      --update    Clear staged update images\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache_clear/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache_clear/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc cache  - Manage cached container images</li> </ul>"},{"location":"tools/nbc/cli/nbc_cache_list/","title":"Nbc cache list","text":""},{"location":"tools/nbc/cli/nbc_cache_list/#nbc-cache-list","title":"nbc cache list","text":"<p>List cached container images</p>"},{"location":"tools/nbc/cli/nbc_cache_list/#synopsis","title":"Synopsis","text":"<p>List cached container images.</p> <p>Use --install-images to list images staged for installation (e.g., on ISO). Use --update-images to list images staged for updates.</p> <p>With --json flag, outputs a JSON object suitable for GUI installers.</p> <p>Examples:   nbc cache list --install-images   nbc cache list --install-images --json   nbc cache list --update-images</p> <pre><code>nbc cache list [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache_list/#options","title":"Options","text":"<pre><code>  -h, --help             help for list\n      --install-images   List staged installation images\n      --update-images    List staged update images\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache_list/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc cache  - Manage cached container images</li> </ul>"},{"location":"tools/nbc/cli/nbc_cache_remove/","title":"Nbc cache remove","text":""},{"location":"tools/nbc/cli/nbc_cache_remove/#nbc-cache-remove","title":"nbc cache remove","text":"<p>Remove a cached image by digest</p>"},{"location":"tools/nbc/cli/nbc_cache_remove/#synopsis","title":"Synopsis","text":"<p>Remove a cached image by its digest or digest prefix.</p> <p>You can specify the full digest (sha256:abc123...) or a unique prefix.</p> <p>Examples:   nbc cache remove sha256:abc123...   nbc cache remove sha256-abc1</p> <pre><code>nbc cache remove &lt;digest&gt; [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache_remove/#options","title":"Options","text":"<pre><code>  -h, --help          help for remove\n      --type string   Cache type: 'install' or 'update' (auto-detected if not specified)\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache_remove/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_cache_remove/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc cache  - Manage cached container images</li> </ul>"},{"location":"tools/nbc/cli/nbc_completion/","title":"Nbc completion","text":""},{"location":"tools/nbc/cli/nbc_completion/#nbc-completion","title":"nbc completion","text":"<p>Generate the autocompletion script for the specified shell</p>"},{"location":"tools/nbc/cli/nbc_completion/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for nbc for the specified shell. See each sub-command's help for details on how to use the generated script.</p>"},{"location":"tools/nbc/cli/nbc_completion/#options","title":"Options","text":"<pre><code>  -h, --help   help for completion\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> <li>nbc completion bash  - Generate the autocompletion script for bash</li> <li>nbc completion fish  - Generate the autocompletion script for fish</li> <li>nbc completion powershell  - Generate the autocompletion script for powershell</li> <li>nbc completion zsh    - Generate the autocompletion script for zsh</li> </ul>"},{"location":"tools/nbc/cli/nbc_completion_bash/","title":"Nbc completion bash","text":""},{"location":"tools/nbc/cli/nbc_completion_bash/#nbc-completion-bash","title":"nbc completion bash","text":"<p>Generate the autocompletion script for bash</p>"},{"location":"tools/nbc/cli/nbc_completion_bash/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for the bash shell.</p> <p>This script depends on the 'bash-completion' package. If it is not installed already, you can install it via your OS's package manager.</p> <p>To load completions in your current shell session:</p> <pre><code>source &lt;(nbc completion bash)\n</code></pre> <p>To load completions for every new session, execute once:</p>"},{"location":"tools/nbc/cli/nbc_completion_bash/#linux","title":"Linux:","text":"<pre><code>nbc completion bash &gt; /etc/bash_completion.d/nbc\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_bash/#macos","title":"macOS:","text":"<pre><code>nbc completion bash &gt; $(brew --prefix)/etc/bash_completion.d/nbc\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>nbc completion bash\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_bash/#options","title":"Options","text":"<pre><code>  -h, --help              help for bash\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_bash/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_bash/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc completion    - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"tools/nbc/cli/nbc_completion_fish/","title":"Nbc completion fish","text":""},{"location":"tools/nbc/cli/nbc_completion_fish/#nbc-completion-fish","title":"nbc completion fish","text":"<p>Generate the autocompletion script for fish</p>"},{"location":"tools/nbc/cli/nbc_completion_fish/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for the fish shell.</p> <p>To load completions in your current shell session:</p> <pre><code>nbc completion fish | source\n</code></pre> <p>To load completions for every new session, execute once:</p> <pre><code>nbc completion fish &gt; ~/.config/fish/completions/nbc.fish\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>nbc completion fish [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_fish/#options","title":"Options","text":"<pre><code>  -h, --help              help for fish\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_fish/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_fish/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc completion    - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"tools/nbc/cli/nbc_completion_powershell/","title":"Nbc completion powershell","text":""},{"location":"tools/nbc/cli/nbc_completion_powershell/#nbc-completion-powershell","title":"nbc completion powershell","text":"<p>Generate the autocompletion script for powershell</p>"},{"location":"tools/nbc/cli/nbc_completion_powershell/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for powershell.</p> <p>To load completions in your current shell session:</p> <pre><code>nbc completion powershell | Out-String | Invoke-Expression\n</code></pre> <p>To load completions for every new session, add the output of the above command to your powershell profile.</p> <pre><code>nbc completion powershell [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_powershell/#options","title":"Options","text":"<pre><code>  -h, --help              help for powershell\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_powershell/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_powershell/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc completion    - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"tools/nbc/cli/nbc_completion_zsh/","title":"Nbc completion zsh","text":""},{"location":"tools/nbc/cli/nbc_completion_zsh/#nbc-completion-zsh","title":"nbc completion zsh","text":"<p>Generate the autocompletion script for zsh</p>"},{"location":"tools/nbc/cli/nbc_completion_zsh/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for the zsh shell.</p> <p>If shell completion is not already enabled in your environment you will need to enable it.  You can execute the following once:</p> <pre><code>echo \"autoload -U compinit; compinit\" &gt;&gt; ~/.zshrc\n</code></pre> <p>To load completions in your current shell session:</p> <pre><code>source &lt;(nbc completion zsh)\n</code></pre> <p>To load completions for every new session, execute once:</p>"},{"location":"tools/nbc/cli/nbc_completion_zsh/#linux","title":"Linux:","text":"<pre><code>nbc completion zsh &gt; \"${fpath[1]}/_nbc\"\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_zsh/#macos","title":"macOS:","text":"<pre><code>nbc completion zsh &gt; $(brew --prefix)/share/zsh/site-functions/_nbc\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>nbc completion zsh [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_zsh/#options","title":"Options","text":"<pre><code>  -h, --help              help for zsh\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_zsh/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_completion_zsh/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc completion    - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"tools/nbc/cli/nbc_download/","title":"Nbc download","text":""},{"location":"tools/nbc/cli/nbc_download/#nbc-download","title":"nbc download","text":"<p>Download a container image to local cache</p>"},{"location":"tools/nbc/cli/nbc_download/#synopsis","title":"Synopsis","text":"<p>Download a container image for offline installation or staged updates.</p> <p>This command downloads a container image and saves it in OCI layout format for later use. The image can be used for:</p> <ul> <li> <p>Offline installation: Embed on a live ISO for installation without     internet access. Use --for-install to save to /var/cache/nbc/staged-install/</p> </li> <li> <p>Staged updates: Download an update now, apply later at a convenient time.     Use --for-update to save to /var/cache/nbc/staged-update/</p> </li> </ul> <p>Multiple installation images can be staged (e.g., different editions), but only one update image at a time.</p> <p>Examples:   # Download image for embedding in an ISO   nbc download --image quay.io/example/myimage:latest --for-install</p> <p># Download update to apply later (uses image from system config)   nbc download --for-update</p> <p># Download specific update image   nbc download --image quay.io/example/myimage:v2.0 --for-update</p> <p># JSON output for scripting   nbc download --image quay.io/example/myimage:latest --for-install --json</p> <pre><code>nbc download [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_download/#options","title":"Options","text":"<pre><code>      --for-install    Save to staged-install cache (for ISO embedding)\n      --for-update     Save to staged-update cache (for offline updates)\n  -h, --help           help for download\n  -i, --image string   Container image reference (required for --for-install, uses system config for --for-update)\n</code></pre>"},{"location":"tools/nbc/cli/nbc_download/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_download/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> </ul>"},{"location":"tools/nbc/cli/nbc_install/","title":"Nbc install","text":""},{"location":"tools/nbc/cli/nbc_install/#nbc-install","title":"nbc install","text":"<p>Install a bootc container to a physical disk</p>"},{"location":"tools/nbc/cli/nbc_install/#synopsis","title":"Synopsis","text":"<p>Install a bootc compatible container image to a physical disk.</p> <p>This command will:   1. Validate the target disk   2. Pull the container image (unless --skip-pull is specified)   3. Wipe the disk (after confirmation)   4. Create partitions (EFI: 2GB, boot: 1GB, root1: 12GB, root2: 12GB, var: remaining)   5. Extract container filesystem   6. Configure system and install bootloader   7. Verify the installation</p> <p>The dual root partitions enable A/B updates for system resilience.</p> <p>Supported filesystems: btrfs (default), ext4</p> <p>With --json flag, outputs streaming JSON Lines for progress updates.</p> <p>Example:   nbc install --image quay.io/example/myimage:latest --device /dev/sda   nbc install --image localhost/myimage --device /dev/nvme0n1 --filesystem ext4   nbc install --image localhost/myimage --device /dev/nvme0n1 --karg console=ttyS0   nbc install --image localhost/myimage --device /dev/sda --json   nbc install --local-image sha256:abc123 --device /dev/sda  # Use staged image   nbc install --device /dev/sda  # Auto-detect staged image on ISO</p> <pre><code>nbc install [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_install/#options","title":"Options","text":"<pre><code>  -d, --device string               Target disk device (required)\n      --encrypt                     Enable LUKS full disk encryption for root and var partitions\n  -f, --filesystem string           Filesystem type for root and var partitions (ext4, btrfs) (default \"btrfs\")\n  -h, --help                        help for install\n  -i, --image string                Container image reference (required unless --local-image or staged image exists)\n  -k, --karg stringArray            Kernel argument to pass (can be specified multiple times)\n      --keyfile string              Path to file containing LUKS passphrase (alternative to --passphrase)\n      --local-image string          Use staged local image by digest (auto-detects from /var/cache/nbc/staged-install/ if not specified)\n      --passphrase string           LUKS passphrase (required when --encrypt is set, unless --keyfile is provided)\n      --root-password-file string   Path to file containing root password to set during installation\n      --skip-pull                   Skip pulling the image (use already pulled image)\n      --tpm2                        Enroll TPM2 for automatic LUKS unlock (no PCR binding)\n</code></pre>"},{"location":"tools/nbc/cli/nbc_install/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_install/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> </ul>"},{"location":"tools/nbc/cli/nbc_interactive-install/","title":"Nbc interactive install","text":""},{"location":"tools/nbc/cli/nbc_interactive-install/#nbc-interactive-install","title":"nbc interactive-install","text":"<p>Interactively install a bootc container to a physical disk</p>"},{"location":"tools/nbc/cli/nbc_interactive-install/#synopsis","title":"Synopsis","text":"<p>Interactively install a bootc compatible container image to a physical disk.</p> <p>This command provides a user-friendly interactive form to configure the installation. It prompts for all the options that the regular 'install' command accepts via flags.</p> <p>Example:   nbc interactive-install</p> <pre><code>nbc interactive-install [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_interactive-install/#options","title":"Options","text":"<pre><code>  -h, --help   help for interactive-install\n</code></pre>"},{"location":"tools/nbc/cli/nbc_interactive-install/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_interactive-install/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> </ul>"},{"location":"tools/nbc/cli/nbc_lint/","title":"Nbc lint","text":""},{"location":"tools/nbc/cli/nbc_lint/#nbc-lint","title":"nbc lint","text":"<p>Check a container image for common issues</p>"},{"location":"tools/nbc/cli/nbc_lint/#synopsis","title":"Synopsis","text":"<p>Lint a container image for common issues that may cause problems when installed with nbc.</p> <p>Checks include:   - SSH host keys (should not be baked into images)   - machine-id (should be empty or 'uninitialized')   - Random seed files (should not be shared)</p> <p>Exit codes:   0 - No errors found (warnings are allowed)   1 - One or more errors found</p> <p>Use --local to run inside a container build (e.g., as the last step in a Dockerfile) to check the current filesystem instead of pulling an image.</p> <p>Use --fix with --local to automatically fix issues (remove SSH keys, truncate machine-id, etc.). Fixed issues don't count as errors.</p> <p>Examples:   # Lint a remote image   nbc lint ghcr.io/myorg/myimage:latest   nbc lint --json docker.io/library/fedora:latest</p> <p># Lint the current filesystem (inside a container build)   nbc lint --local</p> <p># Lint and fix issues in a Dockerfile:   # RUN nbc lint --local --fix</p> <pre><code>nbc lint [image] [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_lint/#options","title":"Options","text":"<pre><code>      --fix     Automatically fix issues (only valid with --local)\n  -h, --help    help for lint\n      --local   Lint the current filesystem instead of a container image (for use inside container builds)\n</code></pre>"},{"location":"tools/nbc/cli/nbc_lint/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_lint/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> </ul>"},{"location":"tools/nbc/cli/nbc_list/","title":"Nbc list","text":""},{"location":"tools/nbc/cli/nbc_list/#nbc-list","title":"nbc list","text":"<p>List available disks</p>"},{"location":"tools/nbc/cli/nbc_list/#synopsis","title":"Synopsis","text":"<p>List all available physical disks on the system.</p> <pre><code>nbc list [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_list/#options","title":"Options","text":"<pre><code>  -h, --help   help for list\n</code></pre>"},{"location":"tools/nbc/cli/nbc_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_list/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> </ul>"},{"location":"tools/nbc/cli/nbc_status/","title":"Nbc status","text":""},{"location":"tools/nbc/cli/nbc_status/#nbc-status","title":"nbc status","text":"<p>Show current system status</p>"},{"location":"tools/nbc/cli/nbc_status/#synopsis","title":"Synopsis","text":"<p>Display the current nbc system status including:   - Installed container image reference and digest   - Boot device and active root partition (slot A or B)   - Root filesystem mount mode (read-only or read-write)   - Bootloader type and filesystem type   - Staged update status (if any downloaded update is ready)</p> <p>With -v (verbose), also displays:   - Installation date and kernel arguments   - Remote update availability check</p> <p>With --json flag, outputs structured JSON including update check results.</p> <p>Example:   nbc status   nbc status -v     # Verbose output with update check   nbc status --json # Machine-readable JSON output</p> <pre><code>nbc status [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_status/#options","title":"Options","text":"<pre><code>  -h, --help   help for status\n</code></pre>"},{"location":"tools/nbc/cli/nbc_status/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_status/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> </ul>"},{"location":"tools/nbc/cli/nbc_update/","title":"Nbc update","text":""},{"location":"tools/nbc/cli/nbc_update/#nbc-update","title":"nbc update","text":"<p>Update system to a new container image using A/B partitions</p>"},{"location":"tools/nbc/cli/nbc_update/#synopsis","title":"Synopsis","text":"<p>Update the system by installing a new container image to the inactive root partition.</p> <p>This command performs an A/B system update:   1. Auto-detects the boot device (or use --device to override)   2. Detects which root partition is currently active   3. Checks if an update is available (compares image digests)   4. Pulls the new container image (unless --skip-pull is specified)   5. Extracts the new filesystem to the inactive root partition   6. Updates the bootloader to boot from the new partition   7. Keeps the old partition as a rollback option</p> <p>Use --check to only check if an update is available without installing.</p> <p>After update, reboot to activate the new system. The previous system remains available in the boot menu for rollback if needed.</p> <p>Use --download-only to download an update without applying it. The update will be staged in /var/cache/nbc/staged-update/ and can be applied later with --local-image or --auto.</p> <p>With --json flag, outputs streaming JSON Lines for progress updates.</p> <p>Example:   nbc update   nbc update --check              # Just check if update available   nbc update --download-only      # Download but don't apply   nbc update --local-image        # Apply staged update   nbc update --auto               # Use staged update if available, else pull   nbc update --image quay.io/example/myimage:v2.0   nbc update --skip-pull   nbc update --device /dev/sda    # Override auto-detection   nbc update --force              # Reinstall even if up-to-date   nbc update --json               # Machine-readable streaming output</p> <pre><code>nbc update [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_update/#options","title":"Options","text":"<pre><code>      --auto               Automatically use staged update if available, otherwise pull from registry\n  -c, --check              Only check if an update is available (don't install)\n  -d, --device string      Target disk device (auto-detected if not specified)\n      --download-only      Download update to cache without applying\n  -f, --force              Force reinstall even if system is up-to-date\n  -h, --help               help for update\n  -i, --image string       Container image reference (uses saved config if not specified)\n  -k, --karg stringArray   Kernel argument to pass (can be specified multiple times)\n      --local-image        Apply update from staged cache (/var/cache/nbc/staged-update/)\n      --skip-pull          Skip pulling the image (use already pulled image)\n</code></pre>"},{"location":"tools/nbc/cli/nbc_update/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_update/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> </ul>"},{"location":"tools/nbc/cli/nbc_validate/","title":"Nbc validate","text":""},{"location":"tools/nbc/cli/nbc_validate/#nbc-validate","title":"nbc validate","text":"<p>Validate a disk for bootc installation</p>"},{"location":"tools/nbc/cli/nbc_validate/#synopsis","title":"Synopsis","text":"<p>Validate that a disk is suitable for bootc installation.</p> <pre><code>nbc validate [flags]\n</code></pre>"},{"location":"tools/nbc/cli/nbc_validate/#options","title":"Options","text":"<pre><code>  -d, --device string   Disk device to validate (required)\n  -h, --help            help for validate\n</code></pre>"},{"location":"tools/nbc/cli/nbc_validate/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -n, --dry-run   dry run mode (no actual changes)\n      --json      output in JSON format for machine-readable output\n  -v, --verbose   verbose output\n</code></pre>"},{"location":"tools/nbc/cli/nbc_validate/#see-also","title":"SEE ALSO","text":"<ul> <li>nbc  - A bootc container installer for physical disks</li> </ul>"}]}